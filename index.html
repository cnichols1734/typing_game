<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Typer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: white;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
        }
        
        canvas {
            display: block;
            background-color: #000;
            width: 90vw;
            height: 90vh;
            margin: auto;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            font-weight: bold;
        }
        
        #game-over, #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10;
        }
        
        #game-over h1, #start-screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ff0000;
        }
        
        button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        .instructions {
            max-width: 600px;
            text-align: center;
            margin: 20px;
            line-height: 1.5;
        }
        
        /* Mobile-specific styles */
        #virtual-keyboard {
            position: absolute;
            bottom: 10px;
            left: 0;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 15px 0;
            display: none; /* Hidden by default, shown on mobile */
            flex-wrap: wrap;
            justify-content: center;
            z-index: 5;
            border-top: 2px solid rgba(76, 175, 80, 0.7);
        }
        
        .key-row {
            display: flex;
            justify-content: center;
            width: 100%;
            margin-bottom: 8px;
        }
        
        .key {
            width: 8.5%;
            height: 45px;
            margin: 0 1%;
            background-color: rgba(40, 40, 40, 0.8);
            color: #4CAF50;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
            font-size: 20px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.7);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5), inset 0 0 2px rgba(76, 175, 80, 0.5);
            border: 1px solid rgba(76, 175, 80, 0.5);
            transition: all 0.1s ease;
        }
        
        .key:active, .key.active {
            background-color: rgba(76, 175, 80, 0.7);
            color: white;
            transform: scale(0.95);
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.7);
        }
        
        #mobile-input {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            #virtual-keyboard {
                display: block;
            }
            
            canvas {
                height: 75vh; /* Make room for virtual keyboard */
            }
            
            #hud {
                font-size: 16px;
            }
            
            #game-over h1, #start-screen h1 {
                font-size: 32px;
            }
            
            .instructions {
                font-size: 14px;
                margin: 10px;
            }
            
            button {
                padding: 10px 20px;
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="hud">
            <div id="score">Score: 0</div>
            <div id="lives">Lives: 3</div>
            <div id="round">Round: 1</div>
        </div>
        
        <div id="start-screen">
            <h1>SPACE TYPER</h1>
            <div class="instructions">
                <p>Type the words on enemy ships to destroy them before they reach your base!</p>
                <p>Typing the first letter of a word locks onto that ship.</p>
                <p>Each correct keystroke fires a laser at the targeted ship.</p>
                <p>If any ship reaches the bottom, you lose a life.</p>
            </div>
            <button id="start-button">Start Game</button>
            <div id="audio-controls" style="margin-top: 20px; display: flex; align-items: center; justify-content: center;">
                <button id="music-toggle" style="background-color: #333; padding: 10px 15px; margin-right: 10px;">
                    ðŸ”Š Music: On
                </button>
            </div>
        </div>
        
        <div id="game-over" style="display: none;">
            <h1>GAME OVER</h1>
            <div id="final-score">Final Score: 0</div>
            <button id="restart-button">Play Again</button>
        </div>
    </div>

    <div id="virtual-keyboard">
        <!-- Virtual keyboard will be generated by JavaScript -->
    </div>
    
    <input type="text" id="mobile-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">

    <script>
        // Game constants
        const CANVAS_WIDTH = Math.floor(window.innerWidth * 0.9);
        const CANVAS_HEIGHT = Math.floor(window.innerHeight * 0.9);
        const PLAYER_SHIP_HEIGHT = 70;
        const PLAYER_SHIP_WIDTH = 80;
        const ENEMY_SPEED_BASE = 1.0;
        const ENEMY_SPAWN_INTERVAL_BASE = 2000;
        const MAX_SHIPS_BASE = 6;
        const WORDS_PER_ROUND = 8;
        const ROUND_TRANSITION_DURATION = 2500; // 3 seconds
        const ROUND_START_DELAY = 1000; // 2 seconds
        const EDGE_PADDING = 100;
        
        // Add after other game constants
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Background music setup
        const BACKGROUND_MUSIC_URL = 'space_theme.mp3'; // Local file in the same directory
        let backgroundMusic = new Audio(BACKGROUND_MUSIC_URL);
        backgroundMusic.loop = true;
        backgroundMusic.volume = 0.15; // Reduced to 15% as this track is more prominent
        
        // Add error handling and loading feedback with better fallback
        backgroundMusic.addEventListener('error', function(e) {
            console.error('Error loading background music:', e);
            // Create a fallback audio using Web Audio API
            createFallbackAudio();
        });
        
        // Create a fallback audio option using Web Audio API
        function createFallbackAudio() {
            console.log('Creating fallback audio...');
            // Store the original Audio object for reference
            const originalAudio = backgroundMusic;
            
            // Create a simple synthesized background sound
            let oscillator1 = null;
            let oscillator2 = null;
            let gainNode = null;
            
            // Replace the backgroundMusic object with a custom object that mimics the Audio interface
            backgroundMusic = {
                isPlaying: false,
                
                play: function() {
                    if (this.isPlaying) return Promise.resolve();
                    
                    return new Promise((resolve) => {
                        try {
                            // Create oscillators for ambient sound
                            oscillator1 = audioContext.createOscillator();
                            oscillator2 = audioContext.createOscillator();
                            gainNode = audioContext.createGain();
                            
                            // Set up parameters
                            oscillator1.type = 'sine';
                            oscillator1.frequency.value = 100;
                            oscillator2.type = 'sine';
                            oscillator2.frequency.value = 103; // Slight detuning for beat effect
                            
                            // Very low volume
                            gainNode.gain.value = 0.05;
                            
                            // Connect nodes
                            oscillator1.connect(gainNode);
                            oscillator2.connect(gainNode);
                            gainNode.connect(audioContext.destination);
                            
                            // Start oscillators
                            oscillator1.start();
                            oscillator2.start();
                            
                            this.isPlaying = true;
                            resolve();
                            
                            // Add LFO for slow modulation
                            const lfo = audioContext.createOscillator();
                            const lfoGain = audioContext.createGain();
                            lfo.frequency.value = 0.1; // Very slow modulation
                            lfoGain.gain.value = 0.02;
                            lfo.connect(lfoGain);
                            lfoGain.connect(gainNode.gain);
                            lfo.start();
                        } catch (e) {
                            console.error('Fallback audio failed:', e);
                            resolve(); // Resolve anyway to prevent game from hanging
                        }
                    });
                },
                
                pause: function() {
                    if (!this.isPlaying) return;
                    
                    try {
                        if (oscillator1) {
                            oscillator1.stop();
                            oscillator1 = null;
                        }
                        if (oscillator2) {
                            oscillator2.stop();
                            oscillator2 = null;
                        }
                        if (gainNode) {
                            gainNode.disconnect();
                            gainNode = null;
                        }
                        this.isPlaying = false;
                    } catch (e) {
                        console.error('Error stopping fallback audio:', e);
                    }
                },
                
                load: function() {
                    // Try loading the original audio again
                    originalAudio.load();
                }
            };
            
            // Add currentTime property (getter/setter)
            Object.defineProperty(backgroundMusic, 'currentTime', {
                get: function() { return 0; },
                set: function(value) { /* Do nothing */ }
            });
            
            console.log('Fallback audio created');
        }
        
        // Word lists by difficulty
        const SHORT_WORDS = [
            'at', 'an', 'as', 'am', 'by', 'do', 'go', 'he', 'hi', 'if', 'in', 'is', 'it', 'me', 'my', 'no', 'of', 'on', 
            'or', 'so', 'to', 'up', 'us', 'we'
        ];
        
        const MEDIUM_WORDS = [
            'and', 'are', 'but', 'can', 'did', 'for', 'get', 'had', 'has', 'her', 'him', 'his', 'how', 'its', 'let', 
            'may', 'new', 'not', 'now', 'off', 'old', 'one', 'our', 'out', 'put', 'say', 'see', 'she', 'the', 'too', 
            'try', 'use', 'was', 'way', 'who', 'why', 'yes', 'you', 'able', 'also', 'away', 'back', 'been', 'both', 
            'call', 'came', 'come', 'does', 'down', 'each', 'even', 'find', 'from', 'give', 'good', 'have', 'here', 
            'into', 'just', 'know', 'like', 'look', 'made', 'make', 'many', 'more', 'most', 'much', 'must', 'only', 
            'over', 'said', 'same', 'some', 'such', 'take', 'than', 'that', 'them', 'then', 'they', 'this', 'time', 
            'very', 'well', 'went', 'were', 'what', 'when', 'will', 'with', 'your'
        ];
        
        const LONG_WORDS = [
            'ability', 'achieve', 'acquire', 'advance', 'against', 'already', 'amazing', 'another', 'asteroid', 'because', 
            'believe', 'between', 'billion', 'brother', 'captain', 'central', 'century', 'certain', 'challenge', 'character', 
            'children', 'complete', 'computer', 'consider', 'continue', 'control', 'creative', 'culture', 'current', 'decision', 
            'defense', 'develop', 'different', 'difficult', 'discover', 'economic', 'education', 'effective', 'electric', 'emergency', 
            'everyone', 'evidence', 'exercise', 'experience', 'explorer', 'external', 'favorite', 'federal', 'feeling', 'finally', 
            'financial', 'forever', 'forward', 'freedom', 'further', 'galactic', 'general', 'generate', 'government', 'graduate', 
            'greatest', 'however', 'hundred', 'identify', 'imagine', 'improve', 'include', 'increase', 'indicate', 'individual', 
            'industry', 'interest', 'internal', 'international', 'language', 'learning', 'machine', 'material', 'measure', 'medical', 
            'meeting', 'military', 'million', 'mission', 'morning', 'movement', 'national', 'natural', 'network', 'nothing', 
            'nuclear', 'observe', 'officer', 'operation', 'opportunity', 'organization', 'original', 'package', 'parallel', 'pattern', 
            'peaceful', 'personal', 'physical', 'planetary', 'platform', 'position', 'positive', 'possible', 'practice', 'prepare', 
            'present', 'pressure', 'prevent', 'primary', 'private', 'probably', 'problem', 'process', 'produce', 'product', 
            'program', 'progress', 'project', 'property', 'protect', 'provide', 'purpose', 'quality', 'quantum', 'question', 
            'quickly', 'realize', 'receive', 'recognize', 'recommend', 'regional', 'relationship', 'remember', 'represent', 'require', 
            'research', 'resource', 'respond', 'responsible', 'satellite', 'science', 'section', 'security', 'separate', 'service', 
            'several', 'significant', 'similar', 'situation', 'solution', 'spaceship', 'specific', 'standard', 'station', 'strategy', 
            'strength', 'structure', 'student', 'subject', 'success', 'support', 'surface', 'system', 'teacher', 'technology', 
            'telescope', 'terminal', 'through', 'together', 'tomorrow', 'training', 'transport', 'universe', 'valuable', 'various', 
            'vehicle', 'version', 'victory', 'weather', 'welcome', 'without', 'working'
        ];
        
        // Game variables
        let canvas, ctx;
        let gameActive = false;
        let score = 0;
        let lives = 3;
        let round = 1;
        let enemyShips = [];
        let currentTypingWord = '';
        let currentTargetShip = null;
        let spawnInterval;
        let lastTime = 0;
        let usedFirstLetters = new Set();
        let lasers = [];
        let explosions = [];
        let stars = [];
        let wordsRemainingInRound = WORDS_PER_ROUND;
        let isRoundTransition = false;
        
        // Game initialization
        window.onload = function() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Create stars for background
            createStars();
            
            // Event listeners
            document.getElementById('start-button').addEventListener('click', startGame);
            document.getElementById('restart-button').addEventListener('click', startGame);
            document.addEventListener('keydown', handleKeyDown);
            
            // Add music toggle functionality
            const musicToggle = document.getElementById('music-toggle');
            let musicEnabled = true;
            
            musicToggle.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent this click from starting the game
                musicEnabled = !musicEnabled;
                
                if (musicEnabled) {
                    musicToggle.textContent = 'ðŸ”Š Music: On';
                    // Preload music
                    backgroundMusic.load();
                } else {
                    musicToggle.textContent = 'ðŸ”‡ Music: Off';
                    // Stop any currently playing music
                    stopBackgroundMusic();
                }
            });
            
            // Setup mobile support
            setupMobileSupport();
            
            // Initial render
            render();
        };
        
        function resizeCanvas() {
            canvas.width = Math.min(CANVAS_WIDTH, window.innerWidth);
            canvas.height = Math.min(CANVAS_HEIGHT, window.innerHeight);
        }
        
        function createStars() {
            stars = [];
            const numStars = 100;
            
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    size: Math.random() * 2 + 1,
                    speed: Math.random() * 0.3 + 0.1
                });
            }
        }
        
        function startGame() {
            // Resume audio context if it's suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // Preload the audio
            backgroundMusic.load();
            
            // Start background music with user interaction
            startBackgroundMusic();
            
            gameActive = true;
            score = 0;
            lives = 3;
            round = 1;
            wordsRemainingInRound = WORDS_PER_ROUND;
            isRoundTransition = false;
            enemyShips = [];
            currentTypingWord = '';
            currentTargetShip = null;
            usedFirstLetters = new Set();
            lasers = [];
            explosions = [];
            
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over').style.display = 'none';
            
            updateHUD();
            
            clearInterval(spawnInterval);
            spawnInterval = setInterval(spawnEnemyShip, getSpawnInterval());
            
            requestAnimationFrame(gameLoop);
        }
        
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            update(deltaTime);
            render();
            
            if (gameActive) {
                requestAnimationFrame(gameLoop);
            }
        }
        
        function update(deltaTime) {
            // Update stars
            updateStars(deltaTime);
            
            // Update enemy ships
            updateEnemyShips(deltaTime);
            
            // Update lasers
            updateLasers(deltaTime);
            
            // Update explosions
            updateExplosions(deltaTime);
            
            // Check for game over
            if (lives <= 0) {
                endGame();
            }
        }
        
        function updateStars(deltaTime) {
            for (let star of stars) {
                star.y += star.speed * deltaTime / 16;
                
                if (star.y > CANVAS_HEIGHT) {
                    star.y = 0;
                    star.x = Math.random() * CANVAS_WIDTH;
                }
            }
        }
        
        function updateEnemyShips(deltaTime) {
            for (let i = enemyShips.length - 1; i >= 0; i--) {
                const ship = enemyShips[i];
                
                // Apply speed multiplier if in error state
                let speedMultiplier = 1.0;
                if (ship.errorState && ship.errorState.isError) {
                    // Error state remains active until the asteroid is destroyed
                    // No need to update error time or reset the state
                    speedMultiplier = ship.errorState.speedMultiplier;
                }
                
                // Move ship down with potential speed boost
                ship.y += getEnemySpeed() * speedMultiplier * deltaTime / 16;
                
                // Rotate asteroid
                if (ship.rotationSpeed) {
                    ship.rotation += ship.rotationSpeed * deltaTime / 16;
                }
                
                // Check if ship reached bottom (adjusted for padding)
                if (ship.y > CANVAS_HEIGHT - ship.height / 2 - EDGE_PADDING / 2) {
                    // Remove ship
                    usedFirstLetters.delete(ship.word[0].toLowerCase());
                    enemyShips.splice(i, 1);
                    
                    // Lose a life
                    lives--;
                    updateHUD();
                    
                    // Play life lost sound
                    playLifeLostSound();
                    
                    // Reset current typing if this was the target
                    if (currentTargetShip === ship) {
                        currentTypingWord = '';
                        currentTargetShip = null;
                    }

                    // Check for round advancement since we removed a ship
                    checkRoundAdvancement();
                }
            }
        }
        
        function updateLasers(deltaTime) {
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                
                // Update laser position
                const dx = laser.targetX - laser.startX;
                const dy = laser.targetY - laser.startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                laser.progress += 0.1 * deltaTime / 16;
                
                // Remove laser if it reached target
                if (laser.progress >= 1) {
                    lasers.splice(i, 1);
                }
            }
        }
        
        function updateExplosions(deltaTime) {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                
                explosion.time += deltaTime / 16;
                
                // Update fragment positions if it's a fragment
                if (explosion.type === 'fragment' && explosion.vx !== undefined && explosion.vy !== undefined) {
                    // Update position based on velocity
                    explosion.x += explosion.vx * deltaTime / 16;
                    explosion.y += explosion.vy * deltaTime / 16;
                    
                    // Add gravity effect
                    explosion.vy += 0.05 * deltaTime / 16;
                    
                    // Update rotation
                    if (explosion.rotationSpeed) {
                        explosion.rotation += explosion.rotationSpeed * deltaTime / 16;
                    }
                }
                
                // Remove explosion if it's done
                if (explosion.time > explosion.duration) {
                    explosions.splice(i, 1);
                }
            }
        }
        
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw stars
            drawStars();
            
            // Draw player ship
            drawPlayerShip();
            
            // Draw enemy ships
            drawEnemyShips();
            
            // Draw lasers
            drawLasers();
            
            // Draw explosions
            drawExplosions();
        }
        
        function drawStars() {
            ctx.fillStyle = 'white';
            
            for (let star of stars) {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawPlayerShip() {
            const x = canvas.width / 2;
            const y = canvas.height - PLAYER_SHIP_HEIGHT / 2;
            
            ctx.fillStyle = '#4CAF50';
            
            // Draw ship body
            ctx.beginPath();
            ctx.moveTo(x, y - PLAYER_SHIP_HEIGHT / 2);
            ctx.lineTo(x - PLAYER_SHIP_WIDTH / 2, y + PLAYER_SHIP_HEIGHT / 2);
            ctx.lineTo(x + PLAYER_SHIP_WIDTH / 2, y + PLAYER_SHIP_HEIGHT / 2);
            ctx.closePath();
            ctx.fill();
            
            // Draw cockpit
            ctx.fillStyle = '#80DEEA';
            ctx.beginPath();
            ctx.arc(x, y, PLAYER_SHIP_HEIGHT / 4, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawEnemyShips() {
            for (const ship of enemyShips) {
                // Check if ship is in error state
                const isError = ship.errorState && ship.errorState.isError;
                
                // Draw error trail if in error state
                if (isError) {
                    // Draw a longer, more prominent trail behind the asteroid
                    const trailLength = 8; // Increased number of trail segments
                    
                    for (let j = 0; j < trailLength; j++) {
                        const trailY = ship.y - (j * 12); // Space out trail segments
                        const opacity = 0.8 - (j * 0.1); // Slower fade out for longer trail
                        
                        // Draw trail segment
                        ctx.save();
                        ctx.translate(ship.x, trailY);
                        if (ship.rotation !== undefined) {
                            ctx.rotate(ship.rotation);
                        }
                        
                        // Draw trail segment as a simplified asteroid shape
                        ctx.beginPath();
                        const trailPoints = 6; // Simplified shape for trail
                        const trailRadius = (ship.width / 2) * (1 - j * 0.1); // Slower shrinking
                        
                        for (let k = 0; k < trailPoints; k++) {
                            const angle = (k / trailPoints) * Math.PI * 2;
                            const jitter = 0.8 + (Math.sin(k * 7) * 0.2);
                            const pointRadius = trailRadius * jitter;
                            
                            const x = Math.cos(angle) * pointRadius;
                            const y = Math.sin(angle) * pointRadius;
                            
                            if (k === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        
                        ctx.closePath();
                        
                        // Fill with more intense red gradient
                        const trailGradient = ctx.createRadialGradient(
                            0, 0, 0,
                            0, 0, trailRadius
                        );
                        
                        trailGradient.addColorStop(0, `rgba(255, 50, 50, ${opacity})`);
                        trailGradient.addColorStop(0.6, `rgba(255, 0, 0, ${opacity * 0.7})`);
                        trailGradient.addColorStop(1, `rgba(255, 0, 0, 0)`);
                        
                        ctx.fillStyle = trailGradient;
                        ctx.fill();
                        
                        // Add outline to trail segments
                        if (j < 3) { // Only for the first few segments
                            ctx.strokeStyle = `rgba(255, 0, 0, ${opacity * 0.8})`;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                    }
                    
                    // Add some particle effects in the trail
                    for (let j = 0; j < 3; j++) {
                        const particleY = ship.y - ((1 + j) * 20 + Math.random() * 10);
                        const particleX = ship.x + (Math.random() - 0.5) * 10;
                        const particleSize = 2 + Math.random() * 3;
                        const particleOpacity = 0.7 - (j * 0.2);
                        
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 100, 50, ${particleOpacity})`;
                        ctx.fill();
                    }
                }
                
                // Determine asteroid color based on word difficulty or error state
                // Use a base gray color for all asteroids, or red if in error state
                let baseColor, outlineColor;
                
                if (isError) {
                    // Error state - red asteroid
                    baseColor = '#FF3333';
                    outlineColor = '#FF0000';
                } else if (ship.word.length <= 3) {
                    // Small asteroids - lighter gray with reddish outline
                    baseColor = '#777777';
                    outlineColor = '#B71C1C';
                } else if (ship.word.length <= 5) {
                    // Medium asteroids - medium gray with orange outline
                    baseColor = '#666666';
                    outlineColor = '#F57F17';
                } else {
                    // Large asteroids - darker gray with purple outline
                    baseColor = '#555555';
                    outlineColor = '#311B92';
                }
                
                // Calculate asteroid radius based on word length
                const radius = ship.width / 2;
                
                // Save context for rotation
                ctx.save();
                ctx.translate(ship.x, ship.y);
                
                // Apply rotation if defined
                if (ship.rotation !== undefined) {
                    ctx.rotate(ship.rotation);
                }
                
                // Highlight targeted asteroid
                if (ship === currentTargetShip) {
                    // Use red highlight for error state, green otherwise
                    ctx.strokeStyle = isError ? '#FF0000' : '#4CAF50';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Add pulsing glow effect for error state
                    if (isError) {
                        // Stronger pulsing effect
                        const pulseSize = 1 + Math.sin(Date.now() / 100) * 0.3;
                        
                        // Outer glow
                        ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, (radius + 10) * pulseSize, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Inner glow
                        ctx.strokeStyle = 'rgba(255, 50, 50, 0.9)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, (radius + 5) * pulseSize, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
                
                // Create irregular asteroid shape
                ctx.beginPath();
                
                // Use the ship's word as a seed for the asteroid shape
                // This ensures each asteroid has a consistent but unique shape
                const seed = ship.word.charCodeAt(0) + ship.word.length;
                const points = 7 + (ship.word.length % 4); // 7-10 points based on word length
                
                // Create irregular polygon
                for (let i = 0; i < points; i++) {
                    const angle = (i / points) * Math.PI * 2;
                    // Vary the radius to create jagged edges
                    const jitter = 0.8 + (Math.sin(seed + i * 7) * 0.2);
                    const pointRadius = radius * jitter;
                    
                    const x = Math.cos(angle) * pointRadius;
                    const y = Math.sin(angle) * pointRadius;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.closePath();
                
                // Create asteroid texture with gradient and noise
                const gradient = ctx.createRadialGradient(
                    -radius/3, -radius/3, radius/10,
                    0, 0, radius * 1.2
                );
                
                gradient.addColorStop(0, baseColor);
                gradient.addColorStop(0.5, baseColor);
                gradient.addColorStop(1, isError ? '#AA0000' : '#444444');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Add asteroid outline
                ctx.strokeStyle = outlineColor;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Add crater details to larger asteroids
                if (ship.word.length > 3) {
                    const craters = Math.min(5, Math.floor(ship.word.length / 2));
                    
                    for (let i = 0; i < craters; i++) {
                        // Position craters based on word characters
                        const craterAngle = ((ship.word.charCodeAt(i % ship.word.length) % 10) / 10) * Math.PI * 2;
                        const craterDist = (radius * 0.6) * ((i + 1) / craters);
                        const craterX = Math.cos(craterAngle) * craterDist;
                        const craterY = Math.sin(craterAngle) * craterDist;
                        const craterSize = radius * (0.15 + (i % 3) * 0.05);
                        
                        // Draw crater
                        ctx.beginPath();
                        ctx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                        ctx.fillStyle = isError ? 'rgba(100, 0, 0, 0.6)' : 'rgba(40, 40, 40, 0.6)';
                        ctx.fill();
                    }
                }
                
                // Add glowing particles for error state
                if (isError) {
                    const particleCount = 8;
                    for (let i = 0; i < particleCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = radius * (0.7 + Math.random() * 0.3);
                        const particleX = Math.cos(angle) * distance;
                        const particleY = Math.sin(angle) * distance;
                        const particleSize = 1 + Math.random() * 2;
                        
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
                        ctx.fill();
                    }
                }
                
                // Restore context before drawing text
                ctx.restore();
                
                // Draw word with adaptive font sizing based on asteroid size and word length
                // Calculate appropriate font size based on asteroid width and word length
                const maxFontSize = 24;
                const minFontSize = 16;
                
                // Calculate font size based on asteroid size and word length
                // Longer words need smaller fonts to fit inside the asteroid
                const fontSizeByWidth = Math.max(minFontSize, Math.min(maxFontSize, ship.width / (ship.word.length * 0.7)));
                
                // Set font with calculated size
                ctx.font = `bold ${Math.floor(fontSizeByWidth)}px Courier New`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Add stronger text shadow for better readability against the asteroid texture
                ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
                ctx.shadowBlur = 6;
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                
                // Highlight typed portion
                if (ship === currentTargetShip && currentTypingWord.length > 0) {
                    const typedPart = ship.word.substring(0, currentTypingWord.length);
                    const remainingPart = ship.word.substring(currentTypingWord.length);
                    
                    // Measure width of typed part and full word
                    const typedWidth = ctx.measureText(typedPart).width;
                    const fullWidth = ctx.measureText(ship.word).width;
                    
                    // Calculate positions to ensure perfect centering
                    const textStartX = ship.x - fullWidth / 2;
                    
                    // Draw the text in two parts
                    // First, draw the typed part in green
                    ctx.fillStyle = '#4CAF50';
                    
                    // Save the current context to restore after drawing the first part
                    ctx.save();
                    
                    // Set a clip region for the first part of the text
                    ctx.beginPath();
                    ctx.rect(ship.x - fullWidth/2, ship.y - fontSizeByWidth, 
                             typedWidth, fontSizeByWidth * 2);
                    ctx.clip();
                    
                    // Draw the full word - the clipping will only show the first part
                    ctx.fillText(ship.word, ship.x, ship.y);
                    
                    // Restore context for the second part
                    ctx.restore();
                    
                    // Now draw the remaining part in white
                    ctx.fillStyle = 'white';
                    
                    // Save context again
                    ctx.save();
                    
                    // Set a clip region for the second part of the text
                    ctx.beginPath();
                    ctx.rect(ship.x - fullWidth/2 + typedWidth, ship.y - fontSizeByWidth,
                             fullWidth - typedWidth, fontSizeByWidth * 2);
                    ctx.clip();
                    
                    // Draw the full word again - the clipping will only show the second part
                    ctx.fillText(ship.word, ship.x, ship.y);
                    
                    // Restore context
                    ctx.restore();
                } else {
                    // Draw full word in white
                    ctx.fillStyle = 'white';
                    ctx.fillText(ship.word, ship.x, ship.y);
                    
                    // Add subtle glow effect for better visibility
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
                    ctx.shadowBlur = 8;
                    ctx.fillText(ship.word, ship.x, ship.y);
                }
                
                // Reset shadow effects
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }
        }
        
        function drawLasers() {
            ctx.lineWidth = 2;
            
            for (const laser of lasers) {
                const startX = canvas.width / 2;
                const startY = canvas.height - PLAYER_SHIP_HEIGHT / 2;
                
                const currentX = startX + (laser.targetX - startX) * laser.progress;
                const currentY = startY + (laser.targetY - startY) * laser.progress;
                
                // Draw laser beam
                ctx.strokeStyle = laser.color;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                
                // Draw laser head
                ctx.fillStyle = laser.color;
                ctx.beginPath();
                ctx.arc(currentX, currentY, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawExplosions() {
            for (const explosion of explosions) {
                const progress = explosion.time / explosion.duration;
                
                if (explosion.type === 'fragment') {
                    // Draw asteroid fragment
                    const fadeStart = 0.7; // When to start fading out
                    const opacity = progress > fadeStart ? 
                        1 - ((progress - fadeStart) / (1 - fadeStart)) : 1;
                    
                    ctx.save();
                    ctx.translate(explosion.x, explosion.y);
                    
                    if (explosion.rotation !== undefined) {
                        ctx.rotate(explosion.rotation);
                    }
                    
                    // Draw irregular fragment shape
                    ctx.beginPath();
                    const points = 5; // Simpler shape for fragments
                    const radius = explosion.radius;
                    
                    for (let i = 0; i < points; i++) {
                        const angle = (i / points) * Math.PI * 2;
                        // Vary the radius to create jagged edges
                        const jitter = 0.7 + (Math.sin(i * 7) * 0.3);
                        const pointRadius = radius * jitter;
                        
                        const x = Math.cos(angle) * pointRadius;
                        const y = Math.sin(angle) * pointRadius;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    ctx.closePath();
                    
                    // Create fragment texture
                    const gradient = ctx.createRadialGradient(
                        0, 0, 0,
                        0, 0, radius
                    );
                    
                    gradient.addColorStop(0, `rgba(120, 120, 120, ${opacity})`);
                    gradient.addColorStop(1, `rgba(80, 80, 80, ${opacity})`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    ctx.strokeStyle = `rgba(60, 60, 60, ${opacity})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    ctx.restore();
                } else {
                    // Draw main explosion
                    const radius = explosion.radius * Math.sin(progress * Math.PI);
                    
                    // Create gradient
                    const gradient = ctx.createRadialGradient(
                        explosion.x, explosion.y, 0,
                        explosion.x, explosion.y, radius
                    );
                    
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                    gradient.addColorStop(0.4, 'rgba(255, 200, 0, 0.8)');
                    gradient.addColorStop(0.7, 'rgba(255, 100, 0, 0.8)');
                    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function spawnEnemyShip() {
            // Don't spawn during round transition or if round is complete
            if (isRoundTransition || wordsRemainingInRound <= 0) {
                return;
            }

            // Check if maximum number of ships reached
            if (enemyShips.length >= getMaxShips()) {
                return;
            }

            // Only spawn if we have words remaining in the round
            if (wordsRemainingInRound > 0) {
                let word;
                let attempts = 0;
                const maxAttempts = 20;
                
                do {
                    word = selectWord();
                    attempts++;
                    
                    if (attempts >= maxAttempts) {
                        return;
                    }
                } while (usedFirstLetters.has(word[0].toLowerCase()));
                
                usedFirstLetters.add(word[0].toLowerCase());
                
                // Create asteroid size based on word length
                // Larger minimum size to ensure text fits comfortably
                const minSize = 40;  // Increased from 25
                const maxSize = 90;  // Increased from 60
                
                // Calculate size based on word length with a steeper scaling factor
                // Short words (2-3 chars): medium-small asteroids
                // Medium words (4-6 chars): medium-large asteroids
                // Long words (7+ chars): large asteroids
                const sizeBase = minSize + (word.length * 7);  // Increased multiplier from 5 to 7
                const size = Math.min(maxSize, sizeBase);
                
                // Add some randomness to make asteroids more varied, but less than before
                // to ensure consistent text fitting
                const randomFactor = 0.95 + (Math.random() * 0.1); // 0.95 to 1.05 (narrower range)
                const finalSize = size * randomFactor;
                
                // Make width and height slightly different for more natural look
                const width = finalSize;
                const height = finalSize * (0.9 + (Math.random() * 0.2));
                
                // Add rotation for asteroids
                const rotation = Math.random() * Math.PI * 2;
                const rotationSpeed = (Math.random() - 0.5) * 0.02; // Random rotation direction and speed
                
                // Adjust spawn position to account for padding
                const ship = {
                    word: word,
                    x: Math.random() * (canvas.width - width - EDGE_PADDING * 2) + width / 2 + EDGE_PADDING,
                    y: -height / 2,
                    width: width,
                    height: height,
                    rotation: rotation,
                    rotationSpeed: rotationSpeed
                };
                
                enemyShips.push(ship);
                wordsRemainingInRound--;
            }
        }
        
        function selectWord() {
            // Early rounds (1-2): mix of short and medium words
            if (round <= 2) {
                const wordPool = [...SHORT_WORDS, ...MEDIUM_WORDS];
                return wordPool[Math.floor(Math.random() * wordPool.length)];
            } 
            // Mid rounds (3-4): medium words and some long words
            else if (round <= 4) {
                const wordPool = [...MEDIUM_WORDS, ...LONG_WORDS.slice(0, 30)];
                return wordPool[Math.floor(Math.random() * wordPool.length)];
            }
            // Advanced rounds (5-9): increasingly favor longer words
            else if (round <= 9) {
                const longWordChance = Math.min(0.8, 0.4 + (round - 4) * 0.1);
                if (Math.random() < longWordChance) {
                    return LONG_WORDS[Math.floor(Math.random() * LONG_WORDS.length)];
                } else {
                    return MEDIUM_WORDS[Math.floor(Math.random() * MEDIUM_WORDS.length)];
                }
            }
            // Expert rounds (10+): chance for extra-long words
            else {
                // 15% chance for extra-long word (10+ characters)
                if (Math.random() < 0.15) {
                    const extraLongWords = LONG_WORDS.filter(word => word.length >= 10);
                    return extraLongWords[Math.floor(Math.random() * extraLongWords.length)];
                }
                // 60% chance for regular long word
                else if (Math.random() < 0.75) {
                    const regularLongWords = LONG_WORDS.filter(word => word.length < 10);
                    return regularLongWords[Math.floor(Math.random() * regularLongWords.length)];
                }
                // 25% chance for medium word
                else {
                    return MEDIUM_WORDS[Math.floor(Math.random() * MEDIUM_WORDS.length)];
                }
            }
        }
        
        function handleKeyDown(event) {
            if (!gameActive) return;
            
            // Get the key pressed
            const key = event.key.toLowerCase();
            
            // Ignore non-letter keys
            if (!/^[a-z]$/.test(key)) {
                return;
            }
            
            processKey(key);
        }
        
        function processKey(key) {
            // If no current target, find a ship that starts with the pressed key
            if (!currentTargetShip) {
                for (const ship of enemyShips) {
                    if (ship.word[0].toLowerCase() === key) {
                        currentTargetShip = ship;
                        currentTypingWord = key;
                        
                        // Initialize error state if not present
                        if (currentTargetShip.errorState === undefined) {
                            currentTargetShip.errorState = {
                                isError: false,
                                speedMultiplier: 1.0
                            };
                        }
                        
                        // Fire laser
                        fireLaser(ship);
                        break;
                    }
                }
            } 
            // If we have a target, check if the key matches the next letter
            else {
                const nextCharIndex = currentTypingWord.length;
                const nextChar = currentTargetShip.word[nextCharIndex].toLowerCase();
                
                if (key === nextChar) {
                    // Correct key
                    currentTypingWord += key;
                    
                    // Fire laser
                    fireLaser(currentTargetShip);
                    
                    // Check if word is complete
                    if (currentTypingWord.length === currentTargetShip.word.length) {
                        destroyShip(currentTargetShip);
                    }
                } else {
                    // Incorrect key - activate error state
                    if (!currentTargetShip.errorState) {
                        currentTargetShip.errorState = {
                            isError: false,
                            speedMultiplier: 1.0
                        };
                    }
                    
                    // Set error state - permanently
                    currentTargetShip.errorState.isError = true;
                    
                    // Increase speed by 20%
                    currentTargetShip.errorState.speedMultiplier = 1.2;
                    
                    // Play error sound
                    playErrorSound();
                    
                    // Add visual feedback for the error
                    const flashOverlay = document.createElement('div');
                    flashOverlay.style.position = 'absolute';
                    flashOverlay.style.top = '0';
                    flashOverlay.style.left = '0';
                    flashOverlay.style.width = '100%';
                    flashOverlay.style.height = '100%';
                    flashOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.2)';
                    flashOverlay.style.pointerEvents = 'none';
                    flashOverlay.style.zIndex = '4';
                    flashOverlay.style.opacity = '0.5';
                    document.getElementById('game-container').appendChild(flashOverlay);
                    
                    // Fade out and remove the flash
                    setTimeout(() => {
                        flashOverlay.style.transition = 'opacity 0.3s ease-out';
                        flashOverlay.style.opacity = '0';
                        setTimeout(() => {
                            document.getElementById('game-container').removeChild(flashOverlay);
                        }, 300);
                    }, 100);
                }
            }
        }
        
        function fireLaser(targetShip) {
            const startX = canvas.width / 2;
            const startY = canvas.height - PLAYER_SHIP_HEIGHT / 2;
            
            lasers.push({
                startX: startX,
                startY: startY,
                targetX: targetShip.x,
                targetY: targetShip.y,
                progress: 0,
                color: '#4CAF50'
            });

            // Play laser sound
            playLaserSound();
        }
        
        function playLaserSound() {
            // Create oscillator for laser sound
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Set up laser sound parameters
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(880, audioContext.currentTime); // Start at A5
            oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.1); // Sweep down to A2
            
            // Set up volume envelope
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            // Connect nodes
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Play sound
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        function destroyShip(ship) {
            // Remove ship from array
            const index = enemyShips.indexOf(ship);
            if (index !== -1) {
                enemyShips.splice(index, 1);
            }
            
            // Remove first letter from used set
            usedFirstLetters.delete(ship.word[0].toLowerCase());
            
            // Create main explosion
            const explosionSize = 20 + ship.word.length * 5;
            explosions.push({
                x: ship.x,
                y: ship.y,
                radius: explosionSize,
                duration: 30,
                time: 0,
                type: 'main'
            });
            
            // Create asteroid fragments
            const fragmentCount = Math.min(8, 3 + Math.floor(ship.word.length / 2));
            
            for (let i = 0; i < fragmentCount; i++) {
                const angle = (i / fragmentCount) * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                const distance = ship.width / 2;
                
                // Create fragment with velocity
                explosions.push({
                    x: ship.x + Math.cos(angle) * distance * 0.5,
                    y: ship.y + Math.sin(angle) * distance * 0.5,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: ship.width / 4 * (0.5 + Math.random() * 0.5),
                    duration: 45,
                    time: 0,
                    type: 'fragment',
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2
                });
            }
            
            // Play explosion sound
            playExplosionSound();
            
            // Award points based on word length
            const points = ship.word.length * 10;
            score += points;
            
            // Reset current typing
            currentTypingWord = '';
            currentTargetShip = null;
            
            // Update HUD
            updateHUD();
            
            // Check for round advancement
            checkRoundAdvancement();
        }
        
        function playExplosionSound() {
            // Create noise for explosion
            const bufferSize = audioContext.sampleRate * 0.5;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            // Generate noise
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            
            // Create noise source
            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            
            // Create filters for explosion effect
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1000, audioContext.currentTime);
            filter.frequency.exponentialRampToValueAtTime(20, audioContext.currentTime + 0.3);
            
            // Create volume envelope
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            // Connect nodes
            noise.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Play sound
            noise.start();
            noise.stop(audioContext.currentTime + 0.3);
        }
        
        function checkRoundAdvancement() {
            // Start next round when all words are destroyed and no ships remain
            if (wordsRemainingInRound <= 0 && enemyShips.length === 0 && !isRoundTransition) {
                startNextRound();
            }
        }
        
        function getEnemySpeed() {
            // Exponential speed increase after round 5
            if (round <= 5) {
                return ENEMY_SPEED_BASE * (1 + (round - 1) * 0.1);
            } else {
                return ENEMY_SPEED_BASE * (1.4 + Math.pow(round - 5, 0.7) * 0.15);
            }
        }
        
        function getSpawnInterval() {
            // Faster spawn rate in later rounds
            if (round <= 5) {
                return Math.max(2000, ENEMY_SPAWN_INTERVAL_BASE - (round - 1) * 200);
            } else {
                return Math.max(1000, ENEMY_SPAWN_INTERVAL_BASE - 1000 - (round - 5) * 100);
            }
        }
        
        function getMaxShips() {
            // More concurrent ships in later rounds
            if (round <= 5) {
                return Math.min(4, 3 + Math.floor((round - 1) / 3));
            } else {
                return Math.min(5, 4 + Math.floor((round - 5) / 2));
            }
        }
        
        function updateHUD() {
            document.getElementById('score').textContent = `Score: ${score}`;
            document.getElementById('lives').textContent = `Lives: ${lives}`;
            document.getElementById('round').textContent = `Round: ${round}`;
        }
        
        function endGame() {
            gameActive = false;
            clearInterval(spawnInterval);
            
            // Stop background music
            stopBackgroundMusic();
            
            // Show game over screen
            document.getElementById('game-over').style.display = 'flex';
            document.getElementById('final-score').textContent = `Final Score: ${score}`;
        }
        
        function startNextRound() {
            round++;
            wordsRemainingInRound = WORDS_PER_ROUND;
            isRoundTransition = true;
            
            // Clear any remaining ships
            enemyShips = [];
            usedFirstLetters.clear();
            
            // Show round transition
            const roundText = document.createElement('div');
            roundText.style.position = 'absolute';
            roundText.style.top = '50%';
            roundText.style.left = '50%';
            roundText.style.transform = 'translate(-50%, -50%)';
            roundText.style.fontSize = '72px';
            roundText.style.color = '#4CAF50';
            roundText.style.fontWeight = 'bold';
            roundText.style.zIndex = '100';
            roundText.textContent = `Round ${round}`;
            document.getElementById('game-container').appendChild(roundText);
            
            // Remove round text and start next round after delay
            setTimeout(() => {
                document.getElementById('game-container').removeChild(roundText);
                isRoundTransition = false;
                
                // Update spawn interval for new round
                clearInterval(spawnInterval);
                spawnInterval = setInterval(spawnEnemyShip, getSpawnInterval());
                
                updateHUD();
            }, ROUND_TRANSITION_DURATION + ROUND_START_DELAY);
        }

        function startBackgroundMusic() {
            // Get the music toggle button to check if music is enabled
            const musicToggle = document.getElementById('music-toggle');
            const musicEnabled = musicToggle ? musicToggle.textContent.includes('On') : true;
            
            // Don't play music if it's disabled
            if (!musicEnabled) {
                console.log('Music is disabled by user preference');
                return;
            }
            
            // Create a user interaction promise to handle autoplay restrictions
            const userInteractionPromise = new Promise((resolve) => {
                // This will be resolved when the user interacts with the page
                document.addEventListener('click', function clickHandler() {
                    document.removeEventListener('click', clickHandler);
                    resolve();
                }, { once: true });
            });

            // Try to play the music
            backgroundMusic.play().catch(error => {
                console.log('Audio playback failed, waiting for user interaction:', error);
                
                // Add a visible music indicator to the HUD
                const musicStatus = document.createElement('div');
                musicStatus.id = 'music-status';
                musicStatus.textContent = 'ðŸ”‡ Music: Click to enable';
                musicStatus.style.cursor = 'pointer';
                musicStatus.style.marginTop = '10px';
                document.getElementById('hud').appendChild(musicStatus);
                
                // Add click handler specifically for the music status
                musicStatus.addEventListener('click', function() {
                    backgroundMusic.play().then(() => {
                        musicStatus.textContent = 'ðŸ”Š Music: Playing';
                        setTimeout(() => {
                            musicStatus.style.opacity = '0.5';
                        }, 2000);
                    }).catch(e => {
                        console.error('Still failed to play audio:', e);
                        musicStatus.textContent = 'ðŸ”‡ Music: Failed to enable';
                    });
                });
            });
        }

        function stopBackgroundMusic() {
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0;
        }

        function setupMobileSupport() {
            // Check if we're on a mobile device or small screen
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                          || window.innerWidth <= 768;
            
            if (isMobile) {
                // Create virtual keyboard
                createVirtualKeyboard();
                
                // Setup mobile input field for triggering the native keyboard
                const mobileInput = document.getElementById('mobile-input');
                
                // Handle mobile input from native keyboard
                mobileInput.addEventListener('input', function(e) {
                    if (e.target.value) {
                        // Process the last character typed
                        const key = e.target.value.slice(-1).toLowerCase();
                        processKey(key);
                        
                        // Clear the input field after a short delay
                        setTimeout(() => {
                            e.target.value = '';
                        }, 10);
                    }
                });
                
                // Show native keyboard when canvas is tapped (optional)
                canvas.addEventListener('touchstart', function(e) {
                    if (gameActive) {
                        // Uncomment the next line if you want the native keyboard to appear on canvas tap
                        // mobileInput.focus();
                    }
                });
                
                // Add a toggle button for the keyboard
                const keyboardToggle = document.createElement('div');
                keyboardToggle.id = 'keyboard-toggle';
                keyboardToggle.textContent = 'âŒ¨ï¸';
                keyboardToggle.style.position = 'absolute';
                keyboardToggle.style.bottom = '10px';
                keyboardToggle.style.right = '10px';
                keyboardToggle.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                keyboardToggle.style.color = '#4CAF50';
                keyboardToggle.style.padding = '10px';
                keyboardToggle.style.borderRadius = '5px';
                keyboardToggle.style.fontSize = '24px';
                keyboardToggle.style.cursor = 'pointer';
                keyboardToggle.style.zIndex = '10';
                keyboardToggle.style.border = '1px solid rgba(76, 175, 80, 0.5)';
                keyboardToggle.style.boxShadow = '0 0 5px rgba(76, 175, 80, 0.5)';
                
                document.getElementById('game-container').appendChild(keyboardToggle);
                
                // Toggle keyboard visibility
                let keyboardVisible = true;
                const virtualKeyboard = document.getElementById('virtual-keyboard');
                
                keyboardToggle.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    keyboardVisible = !keyboardVisible;
                    virtualKeyboard.style.display = keyboardVisible ? 'block' : 'none';
                    keyboardToggle.textContent = keyboardVisible ? 'âŒ¨ï¸' : 'ðŸ”¼';
                    
                    // Adjust canvas height
                    if (keyboardVisible) {
                        canvas.style.height = '75vh';
                    } else {
                        canvas.style.height = '90vh';
                    }
                });
            }
        }

        function createVirtualKeyboard() {
            const keyboard = document.getElementById('virtual-keyboard');
            // Clear any existing content
            keyboard.innerHTML = '';
            
            // Define keyboard rows in QWERTY layout
            const keyboardRows = [
                'qwertyuiop',
                'asdfghjkl',
                'zxcvbnm'
            ];
            
            // Create each row
            keyboardRows.forEach(rowKeys => {
                const rowElement = document.createElement('div');
                rowElement.className = 'key-row';
                
                // Create keys for this row
                for (let i = 0; i < rowKeys.length; i++) {
                    const key = document.createElement('div');
                    key.className = 'key';
                    key.textContent = rowKeys[i];
                    
                    // Add touch event
                    key.addEventListener('touchstart', function(e) {
                        e.preventDefault();
                        processKey(rowKeys[i]);
                        
                        // Visual feedback
                        this.classList.add('active');
                        setTimeout(() => {
                            this.classList.remove('active');
                        }, 150);
                    });
                    
                    rowElement.appendChild(key);
                }
                
                keyboard.appendChild(rowElement);
            });
            
            // Add a retro keyboard label
            const keyboardLabel = document.createElement('div');
            keyboardLabel.style.color = 'rgba(76, 175, 80, 0.7)';
            keyboardLabel.style.textAlign = 'center';
            keyboardLabel.style.fontSize = '12px';
            keyboardLabel.style.fontFamily = 'Courier New, monospace';
            keyboardLabel.style.marginTop = '5px';
            keyboardLabel.style.textShadow = '0 0 5px rgba(76, 175, 80, 0.5)';
            keyboardLabel.textContent = '[ SPACE COMMAND TERMINAL ]';
            keyboard.appendChild(keyboardLabel);
        }

        function playLifeLostSound() {
            // Create a complex alarm sound for life lost
            
            // Main oscillator for the alarm tone
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Create a second oscillator for a more complex sound
            const oscillator2 = audioContext.createOscillator();
            const gainNode2 = audioContext.createGain();
            
            // Create a distortion effect for a harsh warning sound
            const distortion = audioContext.createWaveShaper();
            function makeDistortionCurve(amount) {
                const k = typeof amount === 'number' ? amount : 50;
                const n_samples = 44100;
                const curve = new Float32Array(n_samples);
                const deg = Math.PI / 180;
                
                for (let i = 0; i < n_samples; ++i) {
                    const x = i * 2 / n_samples - 1;
                    curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
                }
                return curve;
            }
            distortion.curve = makeDistortionCurve(20);
            
            // Set up the main alarm tone
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(220, audioContext.currentTime); // A3
            oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.2); // Down to A2
            oscillator.frequency.exponentialRampToValueAtTime(220, audioContext.currentTime + 0.4); // Back to A3
            
            // Set up the secondary tone
            oscillator2.type = 'square';
            oscillator2.frequency.setValueAtTime(440, audioContext.currentTime); // A4
            oscillator2.frequency.exponentialRampToValueAtTime(220, audioContext.currentTime + 0.3); // Down to A3
            
            // Set up volume envelopes
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.05);
            gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.2);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.3);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5);
            
            gainNode2.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode2.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.1);
            gainNode2.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.4);
            
            // Connect nodes
            oscillator.connect(distortion);
            distortion.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator2.connect(gainNode2);
            gainNode2.connect(audioContext.destination);
            
            // Play sound
            oscillator.start();
            oscillator2.start();
            oscillator.stop(audioContext.currentTime + 0.5);
            oscillator2.stop(audioContext.currentTime + 0.5);
            
            // Add visual feedback - flash the screen red briefly
            const flashOverlay = document.createElement('div');
            flashOverlay.style.position = 'absolute';
            flashOverlay.style.top = '0';
            flashOverlay.style.left = '0';
            flashOverlay.style.width = '100%';
            flashOverlay.style.height = '100%';
            flashOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            flashOverlay.style.pointerEvents = 'none';
            flashOverlay.style.zIndex = '4';
            flashOverlay.style.opacity = '0.7';
            document.getElementById('game-container').appendChild(flashOverlay);
            
            // Fade out and remove the flash
            setTimeout(() => {
                flashOverlay.style.transition = 'opacity 0.3s ease-out';
                flashOverlay.style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('game-container').removeChild(flashOverlay);
                }, 300);
            }, 100);
        }

        function playErrorSound() {
            // Create a harsh error sound
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Set up error sound parameters - dissonant frequency
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(220, audioContext.currentTime); // A3
            oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.1); // Down to A2
            
            // Set up volume envelope - short and sharp
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            // Connect nodes
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Play sound
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.2);
        }
    </script>
</body>
</html> 