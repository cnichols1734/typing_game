<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Typer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: white;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
        }
        
        canvas {
            display: block;
            background-color: #000;
            width: 90vw;
            height: 90vh;
            margin: auto;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 24px;
            font-weight: bold;
        }
        
        #game-over, #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10;
        }
        
        #game-over h1, #start-screen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ff0000;
        }
        
        button {
            padding: 15px 30px;
            font-size: 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        .instructions {
            max-width: 600px;
            text-align: center;
            margin: 20px;
            line-height: 1.5;
        }
        
        /* Mobile-specific styles */
        #virtual-keyboard {
            position: absolute;
            bottom: 10px;
            left: 0;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 15px 0;
            display: none; /* Hidden by default, shown on mobile */
            flex-wrap: wrap;
            justify-content: center;
            z-index: 5;
            border-top: 2px solid rgba(76, 175, 80, 0.7);
        }
        
        .key-row {
            display: flex;
            justify-content: center;
            width: 100%;
            margin-bottom: 8px;
        }
        
        .key {
            width: 8.5%;
            height: 45px;
            margin: 0 1%;
            background-color: rgba(40, 40, 40, 0.8);
            color: #4CAF50;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
            font-size: 20px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.7);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5), inset 0 0 2px rgba(76, 175, 80, 0.5);
            border: 1px solid rgba(76, 175, 80, 0.5);
            transition: all 0.1s ease;
        }
        
        .key:active, .key.active {
            background-color: rgba(76, 175, 80, 0.7);
            color: white;
            transform: scale(0.95);
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.7);
        }
        
        #mobile-input {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            #virtual-keyboard {
                display: block;
            }
            
            canvas {
                height: 75vh; /* Make room for virtual keyboard */
            }
            
            #hud {
                font-size: 16px;
            }
            
            #game-over h1, #start-screen h1 {
                font-size: 32px;
            }
            
            .instructions {
                font-size: 14px;
                margin: 10px;
            }
            
            button {
                padding: 10px 20px;
                font-size: 18px;
            }
        }
        
        #hud {
            display: flex;
            flex-direction: column;
            background-color: rgba(0, 20, 0, 0.7);
            border: 1px solid #4CAF50;
            border-radius: 5px;
            padding: 10px 15px;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px rgba(76, 175, 80, 0.7);
            z-index: 5;
        }
        
        #hud div {
            margin: 5px 0;
            position: relative;
            padding-left: 10px;
        }
        
        #hud div:before {
            content: '>';
            position: absolute;
            left: 0;
            color: #4CAF50;
            animation: blink 1.5s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        #score {
            color: #FFEB3B;
        }
        
        #lives {
            color: #FF5252;
        }
        
        #round {
            color: #2196F3;
        }
        
        .life-icon {
            color: #FF5252;
            text-shadow: 0 0 8px #FF0000;
            font-size: 16px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { text-shadow: 0 0 8px #FF0000; }
            50% { text-shadow: 0 0 15px #FF0000; }
            100% { text-shadow: 0 0 8px #FF0000; }
        }
        
        /* Enhanced round transition */
        .round-transition {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            color: #4CAF50;
            font-weight: bold;
            z-index: 100;
            text-shadow: 0 0 20px rgba(76, 175, 80, 0.8);
            animation: roundAppear 2.5s ease-in-out;
        }
        
        @keyframes roundAppear {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="hud">
            <div id="score">Score: 0</div>
            <div id="lives">Lives: 3</div>
            <div id="round">Round: 1</div>
        </div>
        
        <div id="start-screen">
            <h1>SPACE TYPER</h1>
            <div class="instructions">
                <p>Type the words on enemy ships to destroy them before they reach your base!</p>
                <p>Typing the first letter of a word locks onto that ship.</p>
                <p>Each correct keystroke fires a laser at the targeted ship.</p>
                <p>If any ship reaches the bottom, you lose a life.</p>
            </div>
            <button id="start-button">Start Game</button>
            <div id="audio-controls" style="margin-top: 20px; display: flex; align-items: center; justify-content: center;">
                <button id="music-toggle" style="background-color: #333; padding: 10px 15px; margin-right: 10px;">
                    🔊 Music: On
                </button>
            </div>
        </div>
        
        <div id="game-over" style="display: none;">
            <h1>GAME OVER</h1>
            <div id="final-score">Final Score: 0</div>
            <button id="restart-button">Play Again</button>
        </div>
    </div>

    <div id="virtual-keyboard">
        <!-- Virtual keyboard will be generated by JavaScript -->
    </div>
    
    <input type="text" id="mobile-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">

    <script>
        // Game constants
        const CANVAS_WIDTH = Math.floor(window.innerWidth * 0.9);
        const CANVAS_HEIGHT = Math.floor(window.innerHeight * 0.9);
        const PLAYER_SHIP_HEIGHT = 70;
        const PLAYER_SHIP_WIDTH = 80;
        const ENEMY_SPEED_BASE = 1.0;
        const ENEMY_SPAWN_INTERVAL_BASE = 2000;
        const MAX_SHIPS_BASE = 6;
        const WORDS_PER_ROUND = 8;
        const ROUND_TRANSITION_DURATION = 2500; // 3 seconds
        const ROUND_START_DELAY = 1000; // 2 seconds
        const EDGE_PADDING = 100;
        
        // Add after other game constants
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Background music setup
        const BACKGROUND_MUSIC_URL = 'space_theme.mp3'; // Local file in the same directory
        let backgroundMusic = new Audio(BACKGROUND_MUSIC_URL);
        backgroundMusic.loop = true;
        backgroundMusic.volume = 0.15; // Reduced to 15% as this track is more prominent
        
        // Add error handling and loading feedback with better fallback
        backgroundMusic.addEventListener('error', function(e) {
            console.error('Error loading background music:', e);
            // Create a fallback audio using Web Audio API
            createFallbackAudio();
        });
        
        // Create a fallback audio option using Web Audio API
        function createFallbackAudio() {
            console.log('Creating fallback audio...');
            // Store the original Audio object for reference
            const originalAudio = backgroundMusic;
            
            // Create a simple synthesized background sound
            let oscillator1 = null;
            let oscillator2 = null;
            let gainNode = null;
            
            // Replace the backgroundMusic object with a custom object that mimics the Audio interface
            backgroundMusic = {
                isPlaying: false,
                
                play: function() {
                    if (this.isPlaying) return Promise.resolve();
                    
                    return new Promise((resolve) => {
                        try {
                            // Create oscillators for ambient sound
                            oscillator1 = audioContext.createOscillator();
                            oscillator2 = audioContext.createOscillator();
                            gainNode = audioContext.createGain();
                            
                            // Set up parameters
                            oscillator1.type = 'sine';
                            oscillator1.frequency.value = 100;
                            oscillator2.type = 'sine';
                            oscillator2.frequency.value = 103; // Slight detuning for beat effect
                            
                            // Very low volume
                            gainNode.gain.value = 0.05;
                            
                            // Connect nodes
                            oscillator1.connect(gainNode);
                            oscillator2.connect(gainNode);
                            gainNode.connect(audioContext.destination);
                            
                            // Start oscillators
                            oscillator1.start();
                            oscillator2.start();
                            
                            this.isPlaying = true;
                            resolve();
                            
                            // Add LFO for slow modulation
                            const lfo = audioContext.createOscillator();
                            const lfoGain = audioContext.createGain();
                            lfo.frequency.value = 0.1; // Very slow modulation
                            lfoGain.gain.value = 0.02;
                            lfo.connect(lfoGain);
                            lfoGain.connect(gainNode.gain);
                            lfo.start();
                        } catch (e) {
                            console.error('Fallback audio failed:', e);
                            resolve(); // Resolve anyway to prevent game from hanging
                        }
                    });
                },
                
                pause: function() {
                    if (!this.isPlaying) return;
                    
                    try {
                        if (oscillator1) {
                            oscillator1.stop();
                            oscillator1 = null;
                        }
                        if (oscillator2) {
                            oscillator2.stop();
                            oscillator2 = null;
                        }
                        if (gainNode) {
                            gainNode.disconnect();
                            gainNode = null;
                        }
                        this.isPlaying = false;
                    } catch (e) {
                        console.error('Error stopping fallback audio:', e);
                    }
                },
                
                load: function() {
                    // Try loading the original audio again
                    originalAudio.load();
                }
            };
            
            // Add currentTime property (getter/setter)
            Object.defineProperty(backgroundMusic, 'currentTime', {
                get: function() { return 0; },
                set: function(value) { /* Do nothing */ }
            });
            
            console.log('Fallback audio created');
        }
        
        // Word lists by difficulty
        const SHORT_WORDS = [
            // Keep a few essential 2-letter words
            'at', 'in', 'it', 'to', 'up', 'we',
            // Add 3-letter words
            'ace', 'act', 'add', 'age', 'ago', 'aid', 'aim', 'air', 'all', 'and', 'any', 'arm', 'art', 'ask', 'bad',
            'bag', 'bar', 'bat', 'bay', 'bed', 'bee', 'beg', 'bet', 'big', 'bit', 'box', 'boy', 'bug', 'bus', 'but',
            'buy', 'cab', 'can', 'cap', 'car', 'cat', 'cow', 'cry', 'cup', 'cut', 'dad', 'day', 'den', 'did', 'die',
            'dig', 'dim', 'dip', 'dog', 'dot', 'dry', 'due', 'dug', 'ear', 'eat', 'egg', 'end', 'eye', 'fan', 'far',
            'fat', 'few', 'fig', 'fit', 'fix', 'fly', 'fog', 'for', 'fox', 'fun', 'fur', 'gap', 'gas', 'get', 'got',
            'gun', 'guy', 'gym', 'had', 'ham', 'has', 'hat', 'her', 'hid', 'him', 'hip', 'hit', 'hot', 'how', 'hub',
            'hug', 'hut', 'ice', 'ink', 'jar', 'jaw', 'jet', 'job', 'jog', 'joy', 'key', 'kid', 'kit', 'lab', 'lag',
            'lap', 'law', 'lay', 'led', 'leg', 'let', 'lid', 'lie', 'lip', 'lit', 'log', 'lot', 'low', 'mad', 'man',
            'map', 'mat', 'may', 'men', 'met', 'mix', 'mob', 'mom', 'mop', 'mud', 'mug', 'nap', 'net', 'new', 'nod',
            'not', 'now', 'nut', 'odd', 'off', 'oil', 'old', 'one', 'our', 'out', 'owe', 'own', 'pad', 'pan', 'pat',
            'pay', 'pen', 'pet', 'pie', 'pig', 'pin', 'pit', 'pop', 'pot', 'put', 'rad', 'rag', 'ran', 'rap', 'rat',
            'raw', 'red', 'rib', 'rid', 'rim', 'rip', 'rob', 'rod', 'rot', 'row', 'rub', 'rug', 'run', 'sad', 'sat',
            'saw', 'say', 'sea', 'see', 'set', 'sew', 'she', 'shy', 'sip', 'sir', 'sit', 'six', 'ski', 'sky', 'sly',
            'son', 'spy', 'sum', 'sun', 'tab', 'tag', 'tan', 'tap', 'tar', 'tax', 'tea', 'ten', 'the', 'tie', 'tin',
            'tip', 'toe', 'top', 'toy', 'try', 'tub', 'two', 'use', 'van', 'vat', 'vet', 'via', 'war', 'was', 'wax',
            'way', 'web', 'wet', 'who', 'why', 'win', 'wit', 'won', 'wow', 'yes', 'yet', 'you', 'zip', 'zoo'
        ];
        
        const MEDIUM_WORDS = [
            // Only 4-5 letter words
            'able', 'acid', 'aged', 'also', 'area', 'army', 'away', 'baby', 'back', 'ball', 'band', 'bank', 'base',
            'bath', 'bear', 'beat', 'been', 'beer', 'bell', 'belt', 'best', 'bird', 'blow', 'blue', 'boat', 'body',
            'bomb', 'bond', 'bone', 'book', 'boom', 'born', 'boss', 'both', 'bowl', 'bulk', 'burn', 'bush', 'busy',
            'call', 'calm', 'came', 'camp', 'card', 'care', 'case', 'cash', 'cast', 'cell', 'chat', 'chip', 'city',
            'club', 'coal', 'coat', 'code', 'cold', 'come', 'cook', 'cool', 'cope', 'copy', 'core', 'cost', 'crew',
            'crop', 'dark', 'data', 'date', 'dawn', 'days', 'dead', 'deal', 'dean', 'dear', 'debt', 'deep', 'deny',
            'desk', 'dial', 'diet', 'dirt', 'dish', 'disk', 'does', 'done', 'door', 'dose', 'down', 'draw', 'drew',
            'drop', 'drug', 'dual', 'duke', 'dust', 'duty', 'each', 'earn', 'ease', 'east', 'easy', 'edge', 'else',
            'even', 'ever', 'evil', 'exit', 'face', 'fact', 'fade', 'fail', 'fair', 'fall', 'farm', 'fast', 'fate',
            'fear', 'feed', 'feel', 'feet', 'fell', 'felt', 'file', 'fill', 'film', 'find', 'fine', 'fire', 'firm',
            'fish', 'five', 'flat', 'flow', 'food', 'foot', 'ford', 'form', 'fort', 'four', 'free', 'from', 'fuel',
            'full', 'fund', 'gain', 'game', 'gate', 'gave', 'gear', 'gene', 'gift', 'girl', 'give', 'glad', 'goal',
            'goes', 'gold', 'golf', 'gone', 'good', 'gray', 'grew', 'grey', 'grow', 'gulf', 'hair', 'half', 'hall',
            'hand', 'hang', 'hard', 'harm', 'hate', 'have', 'head', 'hear', 'heat', 'held', 'hell', 'help', 'here',
            'hero', 'high', 'hill', 'hire', 'hold', 'hole', 'holy', 'home', 'hope', 'host', 'hour', 'huge', 'hung',
            'hunt', 'hurt', 'idea', 'inch', 'into', 'iron', 'item', 'jack', 'jane', 'jean', 'john', 'join', 'jump',
            'jury', 'just', 'keen', 'keep', 'kent', 'kept', 'kick', 'kill', 'kind', 'king', 'knee', 'knew', 'know',
            'lack', 'lady', 'laid', 'lake', 'land', 'lane', 'last', 'late', 'lead', 'left', 'less', 'life', 'lift',
            'like', 'line', 'link', 'list', 'live', 'load', 'loan', 'lock', 'logo', 'long', 'look', 'lord', 'lose',
            'loss', 'lost', 'love', 'luck', 'made', 'mail', 'main', 'make', 'male', 'many', 'mark', 'mass', 'matt',
            'meal', 'mean', 'meat', 'meet', 'menu', 'mere', 'mike', 'mile', 'milk', 'mill', 'mind', 'mine', 'miss',
            'mode', 'mood', 'moon', 'more', 'most', 'move', 'much', 'must', 'name', 'navy', 'near', 'neck', 'need',
            'news', 'next', 'nice', 'nick', 'nine', 'none', 'nose', 'note', 'okay', 'once', 'only', 'onto', 'open',
            'oral', 'over', 'pace', 'pack', 'page', 'paid', 'pain', 'pair', 'palm', 'park', 'part', 'pass', 'past',
            'path', 'peak', 'pick', 'pink', 'pipe', 'plan', 'play', 'plot', 'plug', 'plus', 'poll', 'pool', 'poor',
            'port', 'post', 'pull', 'pure', 'push', 'race', 'rail', 'rain', 'rank', 'rare', 'rate', 'read', 'real',
            'rear', 'rely', 'rent', 'rest', 'rice', 'rich', 'ride', 'ring', 'rise', 'risk', 'road', 'rock', 'role',
            'roll', 'roof', 'room', 'root', 'rose', 'rule', 'rush', 'ruth', 'safe', 'said', 'sake', 'sale', 'salt',
            'same', 'sand', 'save', 'seat', 'seed', 'seek', 'seem', 'seen', 'self', 'sell', 'send', 'sent', 'sept',
            'ship', 'shop', 'shot', 'show', 'shut', 'sick', 'side', 'sign', 'site', 'size', 'skin', 'slip', 'slow',
            'snow', 'soft', 'soil', 'sold', 'sole', 'some', 'song', 'soon', 'sort', 'soul', 'spot', 'star', 'stay',
            'step', 'stop', 'such', 'suit', 'sure', 'take', 'tale', 'talk', 'tall', 'tank', 'tape', 'task', 'team',
            'tech', 'tell', 'tend', 'term', 'test', 'text', 'than', 'that', 'them', 'then', 'they', 'thin', 'this',
            'thus', 'time', 'tiny', 'told', 'toll', 'tone', 'tony', 'took', 'tool', 'tour', 'town', 'tree', 'trip',
            'true', 'tune', 'turn', 'twin', 'type', 'unit', 'upon', 'used', 'user', 'vary', 'vast', 'very', 'vice',
            'view', 'vote', 'wage', 'wait', 'wake', 'walk', 'wall', 'want', 'ward', 'warm', 'wash', 'wave', 'ways',
            'weak', 'wear', 'week', 'well', 'went', 'were', 'west', 'what', 'when', 'whom', 'wide', 'wife', 'wild',
            'will', 'wind', 'wine', 'wing', 'wire', 'wise', 'wish', 'with', 'wood', 'word', 'wore', 'work', 'yard',
            'yeah', 'year', 'your', 'zero', 'zone'
        ];
        
        const LONG_WORDS = [
            'ability', 'achieve', 'acquire', 'advance', 'against', 'already', 'amazing', 'another', 'asteroid', 'because', 'bryant',
            'believe', 'between', 'billion', 'brother', 'captain', 'central', 'century', 'certain', 'challenge', 'character', 
            'children', 'complete', 'computer', 'consider', 'corbin', 'continue', 'control', 'creative', 'culture', 'current', 'decision', 
            'defense', 'develop', 'different', 'difficult', 'discover', 'economic', 'education', 'effective', 'electric', 'emergency', 
            'everyone', 'evidence', 'exercise', 'experience', 'explorer', 'external', 'favorite', 'federal', 'feeling', 'finally', 
            'financial', 'forever', 'forward', 'freedom', 'further', 'galactic', 'geordie', 'general', 'generate', 'government', 'graduate', 
            'greatest', 'however', 'hundred', 'identify', 'imagine', 'improve', 'include', 'increase', 'indicate', 'individual', 
            'industry', 'interest', 'internal', 'international', 'language', 'learning', 'machine', 'material', 'matthew', 'measure', 'medical', 
            'meeting', 'military', 'million', 'mission', 'morning', 'movement', 'national', 'natural', 'network', 'nothing', 
            'nuclear', 'observe', 'officer', 'operation', 'organization', 'original', 'package', 'parallel', 'pattern', 
            'peaceful', 'personal', 'physical', 'planetary', 'platform', 'position', 'positive', 'possible', 'practice', 'prepare', 
            'present', 'pressure', 'prevent', 'primary', 'private', 'probably', 'problem', 'process', 'produce', 'product', 
            'program', 'progress', 'project', 'property', 'protect', 'provide', 'purpose', 'quality', 'quantum', 'question', 
            'quickly', 'realize', 'receive', 'recognize', 'recommend', 'regional', 'relationship', 'remember', 'represent', 'require', 
            'research', 'resource', 'respond', 'responsible', 'satellite', 'science', 'section', 'security', 'separate', 'service', 
            'several', 'significant', 'similar', 'situation', 'solution', 'spaceship', 'specific', 'standard', 'station', 'strategy', 
            'strength', 'structure', 'student', 'subject', 'success', 'support', 'surface', 'system', 'teacher', 'technology', 
            'telescope', 'terminal', 'through', 'together', 'tomorrow', 'training', 'transport', 'universe', 'valuable', 'various', 
            'vehicle', 'version', 'victory', 'weather', 'welcome', 'without', 'working'
        ];
        
        // Game variables
        let canvas, ctx;
        let gameActive = false;
        let score = 0;
        let lives = 3;
        let round = 1;
        let enemyShips = [];
        let currentTypingWord = '';
        let currentTargetShip = null;
        let spawnInterval;
        let lastTime = 0;
        let usedFirstLetters = new Set();
        let lasers = [];
        let explosions = [];
        let stars = [];
        let wordsRemainingInRound = WORDS_PER_ROUND;
        let isRoundTransition = false;
        
        // Game initialization
        window.onload = function() {
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Create stars for background
            createStars();
            
            // Event listeners
            document.getElementById('start-button').addEventListener('click', startGame);
            document.getElementById('restart-button').addEventListener('click', startGame);
            document.addEventListener('keydown', handleKeyDown);
            
            // Add music toggle functionality
            const musicToggle = document.getElementById('music-toggle');
            let musicEnabled = true;
            
            musicToggle.addEventListener('click', function(e) {
                e.stopPropagation(); // Prevent this click from starting the game
                musicEnabled = !musicEnabled;
                
                if (musicEnabled) {
                    musicToggle.textContent = '🔊 Music: On';
                    // Preload music
                    backgroundMusic.load();
                } else {
                    musicToggle.textContent = '🔇 Music: Off';
                    // Stop any currently playing music
                    stopBackgroundMusic();
                }
            });
            
            // Setup mobile support
            setupMobileSupport();
            
            // Setup enhanced HUD
            setupEnhancedHUD();
            
            // Initial render
            render();
        };
        
        function resizeCanvas() {
            canvas.width = Math.min(CANVAS_WIDTH, window.innerWidth);
            canvas.height = Math.min(CANVAS_HEIGHT, window.innerHeight);
        }
        
        function createStars() {
            stars = [];
            // Create three layers of stars for parallax effect
            const numStarsLayer1 = 70;  // Distant stars (slow)
            const numStarsLayer2 = 40;  // Mid-distance stars (medium)
            const numStarsLayer3 = 20;  // Close stars (fast)
            
            // Layer 1 - Distant stars (small, slow, dim)
            for (let i = 0; i < numStarsLayer1; i++) {
                stars.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    size: Math.random() * 1.5 + 0.5,
                    speed: Math.random() * 0.15 + 0.05,
                    layer: 1,
                    brightness: 0.6 + Math.random() * 0.2,
                    twinkleSpeed: 0.001 + Math.random() * 0.003,
                    twinklePhase: Math.random() * Math.PI * 2
                });
            }
            
            // Layer 2 - Mid-distance stars (medium, medium speed, brighter)
            for (let i = 0; i < numStarsLayer2; i++) {
                stars.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    size: Math.random() * 2 + 1,
                    speed: Math.random() * 0.3 + 0.2,
                    layer: 2,
                    brightness: 0.8 + Math.random() * 0.2,
                    twinkleSpeed: 0.002 + Math.random() * 0.004,
                    twinklePhase: Math.random() * Math.PI * 2,
                    color: Math.random() < 0.3 ? getRandomStarColor() : null // Some colored stars
                });
            }
            
            // Layer 3 - Close stars (larger, faster, brightest)
            for (let i = 0; i < numStarsLayer3; i++) {
                stars.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    size: Math.random() * 2.5 + 1.5,
                    speed: Math.random() * 0.5 + 0.3,
                    layer: 3,
                    brightness: 0.9 + Math.random() * 0.1,
                    twinkleSpeed: 0.003 + Math.random() * 0.005,
                    twinklePhase: Math.random() * Math.PI * 2,
                    color: Math.random() < 0.5 ? getRandomStarColor() : null // More colored stars
                });
            }
        }
        
        // Helper function to get random star colors
        function getRandomStarColor() {
            const colors = [
                'rgba(200, 200, 255, 1)', // Blue-white
                'rgba(255, 200, 200, 1)', // Red-white
                'rgba(255, 230, 200, 1)', // Yellow-white
                'rgba(200, 255, 200, 1)'  // Green-white
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        function startGame() {
            // Resume audio context if it's suspended
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // Preload the audio
            backgroundMusic.load();
            
            // Start background music with user interaction
            startBackgroundMusic();
            
            gameActive = true;
            score = 0;
            lives = 3;
            round = 1;
            wordsRemainingInRound = WORDS_PER_ROUND;
            isRoundTransition = false;
            enemyShips = [];
            currentTypingWord = '';
            currentTargetShip = null;
            usedFirstLetters = new Set();
            lasers = [];
            explosions = [];
            
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over').style.display = 'none';
            
            updateHUD();
            
            clearInterval(spawnInterval);
            spawnInterval = setInterval(spawnEnemyShip, getSpawnInterval());
            
            requestAnimationFrame(gameLoop);
        }
        
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            update(deltaTime);
            render();
            
            if (gameActive) {
                requestAnimationFrame(gameLoop);
            }
        }
        
        function update(deltaTime) {
            // Update stars
            updateStars(deltaTime);
            
            // Update enemy ships
            updateEnemyShips(deltaTime);
            
            // Update lasers
            updateLasers(deltaTime);
            
            // Update explosions
            updateExplosions(deltaTime);
            
            // Check for game over
            if (lives <= 0) {
                endGame();
            }
        }
        
        function updateStars(deltaTime) {
            for (let star of stars) {
                // Update position based on layer speed
                star.y += star.speed * deltaTime / 16;
                
                // Update twinkle effect
                star.twinklePhase += star.twinkleSpeed * deltaTime;
                
                // Wrap around when star goes off screen
                if (star.y > CANVAS_HEIGHT) {
                    star.y = 0;
                    star.x = Math.random() * CANVAS_WIDTH;
                }
            }
        }
        
        function updateEnemyShips(deltaTime) {
            for (let i = enemyShips.length - 1; i >= 0; i--) {
                const ship = enemyShips[i];
                
                // Apply speed multiplier if in error state
                let speedMultiplier = 1.0;
                if (ship.errorState && ship.errorState.isError) {
                    // Error state remains active until the asteroid is destroyed
                    // No need to update error time or reset the state
                    speedMultiplier = ship.errorState.speedMultiplier;
                }
                
                // Move ship down with potential speed boost
                ship.y += getEnemySpeed() * speedMultiplier * deltaTime / 16;
                
                // Rotate asteroid
                if (ship.rotationSpeed) {
                    ship.rotation += ship.rotationSpeed * deltaTime / 16;
                }
                
                // Check if ship reached bottom (adjusted for padding)
                if (ship.y > CANVAS_HEIGHT - ship.height / 2 - EDGE_PADDING / 2) {
                    // Remove ship
                    usedFirstLetters.delete(ship.word[0].toLowerCase());
                    enemyShips.splice(i, 1);
                    
                    // Lose a life
                    lives--;
                    updateHUD();
                    
                    // Play life lost sound
                    playLifeLostSound();
                    
                    // Reset current typing if this was the target
                    if (currentTargetShip === ship) {
                        currentTypingWord = '';
                        currentTargetShip = null;
                    }

                    // Check for round advancement since we removed a ship
                    checkRoundAdvancement();
                }
            }
        }
        
        function updateLasers(deltaTime) {
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                
                // Update laser position
                const dx = laser.targetX - laser.startX;
                const dy = laser.targetY - laser.startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Faster progress for a more dynamic feel
                laser.progress += 0.12 * deltaTime / 16;
                
                // Calculate current position
                const currentX = laser.startX + (laser.targetX - laser.startX) * laser.progress;
                const currentY = laser.startY + (laser.targetY - laser.startY) * laser.progress;
                
                // Add particles along the laser path
                if (Math.random() < 0.3) {
                    // Add particles with slight offset from laser path
                    const particleOffsetX = (Math.random() - 0.5) * 5;
                    const particleOffsetY = (Math.random() - 0.5) * 5;
                    
                    laser.particles.push({
                        x: currentX + particleOffsetX,
                        y: currentY + particleOffsetY,
                        size: 1 + Math.random() * 2,
                        life: 1.0,
                        decay: 0.02 + Math.random() * 0.03
                    });
                }
                
                // Update existing particles
                for (let j = laser.particles.length - 1; j >= 0; j--) {
                    const particle = laser.particles[j];
                    particle.life -= particle.decay * deltaTime / 16;
                    
                    if (particle.life <= 0) {
                        laser.particles.splice(j, 1);
                    }
                }
                
                // Remove laser if it reached target
                if (laser.progress >= 1) {
                    lasers.splice(i, 1);
                }
            }
        }
        
        function updateExplosions(deltaTime) {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                
                explosion.time += deltaTime / 16;
                
                // Update positions for moving explosion types
                if (explosion.vx !== undefined && explosion.vy !== undefined) {
                    // Update position based on velocity
                    explosion.x += explosion.vx * deltaTime / 16;
                    explosion.y += explosion.vy * deltaTime / 16;
                    
                    // Add gravity effect for fragments and particles
                    if (explosion.type === 'fragment' || explosion.type === 'particle') {
                        explosion.vy += 0.05 * deltaTime / 16;
                    }
                    
                    // Update rotation for fragments
                    if (explosion.type === 'fragment' && explosion.rotationSpeed) {
                        explosion.rotation += explosion.rotationSpeed * deltaTime / 16;
                    }
                }
                
                // Remove explosion if it's done
                if (explosion.time > explosion.duration) {
                    explosions.splice(i, 1);
                }
            }
        }
        
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw stars
            drawStars();
            
            // Draw player ship
            drawPlayerShip();
            
            // Draw enemy ships
            drawEnemyShips();
            
            // Draw lasers
            drawLasers();
            
            // Draw explosions
            drawExplosions();
        }
        
        function drawStars() {
            // Draw stars by layer (back to front)
            for (let layer = 1; layer <= 3; layer++) {
                for (let star of stars.filter(s => s.layer === layer)) {
                    // Calculate twinkle effect
                    const twinkle = 0.7 + 0.3 * Math.sin(star.twinklePhase);
                    const brightness = star.brightness * twinkle;
                    
                    // Set star color with brightness
                    if (star.color) {
                        ctx.fillStyle = star.color;
                    } else {
                        ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
                    }
                    
                    // Draw star
                    ctx.beginPath();
                    
                    // Larger stars in layer 3 get a more complex shape
                    if (star.layer === 3 && star.size > 2.5) {
                        // Draw a four-point star
                        const outerRadius = star.size;
                        const innerRadius = star.size * 0.4;
                        
                        for (let i = 0; i < 8; i++) {
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const angle = (i / 8) * Math.PI * 2;
                            const x = star.x + Math.cos(angle) * radius;
                            const y = star.y + Math.sin(angle) * radius;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                        
                        // Add glow effect for bright stars
                        ctx.save();
                        ctx.globalAlpha = 0.3 * brightness;
                        ctx.shadowColor = star.color || 'white';
                        ctx.shadowBlur = 5;
                        ctx.fill();
                        ctx.restore();
                    } else {
                        // Simple circle for smaller stars
                        ctx.arc(star.x, star.y, star.size * twinkle, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }
        
        function drawPlayerShip() {
            const x = canvas.width / 2;
            const y = canvas.height - PLAYER_SHIP_HEIGHT / 2;
            
            // Create engine glow effect
            const engineGlowTime = Date.now() / 50; // Time factor for animation
            const engineGlowSize = 15 + Math.sin(engineGlowTime) * 5; // Pulsing size
            
            // Draw engine glow
            const engineGlow = ctx.createRadialGradient(
                x, y + PLAYER_SHIP_HEIGHT / 2, 0,
                x, y + PLAYER_SHIP_HEIGHT / 2, engineGlowSize
            );
            engineGlow.addColorStop(0, 'rgba(0, 255, 200, 0.8)');
            engineGlow.addColorStop(0.5, 'rgba(0, 200, 150, 0.5)');
            engineGlow.addColorStop(1, 'rgba(0, 100, 100, 0)');
            
            ctx.fillStyle = engineGlow;
            ctx.beginPath();
            ctx.arc(x, y + PLAYER_SHIP_HEIGHT / 2, engineGlowSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw engine thrust particles
            for (let i = 0; i < 5; i++) {
                const particleSize = 2 + Math.random() * 3;
                const particleX = x + (Math.random() - 0.5) * 10;
                const particleY = y + PLAYER_SHIP_HEIGHT / 2 + 5 + Math.random() * 15;
                const particleOpacity = 0.7 - (particleY - (y + PLAYER_SHIP_HEIGHT / 2)) / 20;
                
                ctx.fillStyle = `rgba(0, 255, 200, ${particleOpacity})`;
                ctx.beginPath();
                ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw ship body with gradient
            const shipGradient = ctx.createLinearGradient(
                x, y - PLAYER_SHIP_HEIGHT / 2,
                x, y + PLAYER_SHIP_HEIGHT / 2
            );
            shipGradient.addColorStop(0, '#4CAF50');
            shipGradient.addColorStop(0.7, '#388E3C');
            shipGradient.addColorStop(1, '#1B5E20');
            
            ctx.fillStyle = shipGradient;
            
            // Draw main ship body
            ctx.beginPath();
            ctx.moveTo(x, y - PLAYER_SHIP_HEIGHT / 2);
            ctx.lineTo(x - PLAYER_SHIP_WIDTH / 2, y + PLAYER_SHIP_HEIGHT / 2);
            ctx.lineTo(x + PLAYER_SHIP_WIDTH / 2, y + PLAYER_SHIP_HEIGHT / 2);
            ctx.closePath();
            ctx.fill();
            
            // Add ship details - wings
            ctx.fillStyle = '#2E7D32';
            
            // Left wing
            ctx.beginPath();
            ctx.moveTo(x - PLAYER_SHIP_WIDTH / 4, y);
            ctx.lineTo(x - PLAYER_SHIP_WIDTH / 2 - 10, y + PLAYER_SHIP_HEIGHT / 4);
            ctx.lineTo(x - PLAYER_SHIP_WIDTH / 2, y + PLAYER_SHIP_HEIGHT / 2);
            ctx.lineTo(x - PLAYER_SHIP_WIDTH / 4, y + PLAYER_SHIP_HEIGHT / 4);
            ctx.closePath();
            ctx.fill();
            
            // Right wing
            ctx.beginPath();
            ctx.moveTo(x + PLAYER_SHIP_WIDTH / 4, y);
            ctx.lineTo(x + PLAYER_SHIP_WIDTH / 2 + 10, y + PLAYER_SHIP_HEIGHT / 4);
            ctx.lineTo(x + PLAYER_SHIP_WIDTH / 2, y + PLAYER_SHIP_HEIGHT / 2);
            ctx.lineTo(x + PLAYER_SHIP_WIDTH / 4, y + PLAYER_SHIP_HEIGHT / 4);
            ctx.closePath();
            ctx.fill();
            
            // Add metallic highlights
            ctx.strokeStyle = 'rgba(200, 255, 200, 0.7)';
            ctx.lineWidth = 1;
            
            // Highlight on main body
            ctx.beginPath();
            ctx.moveTo(x - PLAYER_SHIP_WIDTH / 4, y - PLAYER_SHIP_HEIGHT / 4);
            ctx.lineTo(x + PLAYER_SHIP_WIDTH / 4, y - PLAYER_SHIP_HEIGHT / 4);
            ctx.stroke();
            
            // Highlight on wings
            ctx.beginPath();
            ctx.moveTo(x - PLAYER_SHIP_WIDTH / 3, y + PLAYER_SHIP_HEIGHT / 6);
            ctx.lineTo(x - PLAYER_SHIP_WIDTH / 2 - 5, y + PLAYER_SHIP_HEIGHT / 3);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(x + PLAYER_SHIP_WIDTH / 3, y + PLAYER_SHIP_HEIGHT / 6);
            ctx.lineTo(x + PLAYER_SHIP_WIDTH / 2 + 5, y + PLAYER_SHIP_HEIGHT / 3);
            ctx.stroke();
            
            // Draw cockpit with glow effect
            ctx.save();
            ctx.shadowColor = 'rgba(100, 255, 255, 0.8)';
            ctx.shadowBlur = 10;
            
            const cockpitGradient = ctx.createRadialGradient(
                x, y, 0,
                x, y, PLAYER_SHIP_HEIGHT / 4
            );
            cockpitGradient.addColorStop(0, '#E0F7FA');
            cockpitGradient.addColorStop(0.7, '#80DEEA');
            cockpitGradient.addColorStop(1, '#26C6DA');
            
            ctx.fillStyle = cockpitGradient;
            ctx.beginPath();
            ctx.arc(x, y, PLAYER_SHIP_HEIGHT / 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Add cockpit detail
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x, y, PLAYER_SHIP_HEIGHT / 6, 0, Math.PI, true);
            ctx.stroke();
        }
        
        function drawEnemyShips() {
            for (const ship of enemyShips) {
                // Check if ship is in error state
                const isError = ship.errorState && ship.errorState.isError;
                
                // Draw error trail if in error state
                if (isError) {
                    // Draw a longer, more prominent trail behind the asteroid
                    const trailLength = 8; // Increased number of trail segments
                    
                    for (let j = 0; j < trailLength; j++) {
                        const trailY = ship.y - (j * 12); // Space out trail segments
                        const opacity = 0.8 - (j * 0.1); // Slower fade out for longer trail
                        
                        // Draw trail segment
                        ctx.save();
                        ctx.translate(ship.x, trailY);
                        if (ship.rotation !== undefined) {
                            ctx.rotate(ship.rotation);
                        }
                        
                        // Draw trail segment as a simplified asteroid shape
                        ctx.beginPath();
                        const trailPoints = 6; // Simplified shape for trail
                        const trailRadius = (ship.width / 2) * (1 - j * 0.1); // Slower shrinking
                        
                        for (let k = 0; k < trailPoints; k++) {
                            const angle = (k / trailPoints) * Math.PI * 2;
                            const jitter = 0.8 + (Math.sin(k * 7) * 0.2);
                            const pointRadius = trailRadius * jitter;
                            
                            const x = Math.cos(angle) * pointRadius;
                            const y = Math.sin(angle) * pointRadius;
                            
                            if (k === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        
                        ctx.closePath();
                        
                        // Fill with more intense red gradient
                        const trailGradient = ctx.createRadialGradient(
                            0, 0, 0,
                            0, 0, trailRadius
                        );
                        
                        trailGradient.addColorStop(0, `rgba(255, 50, 50, ${opacity})`);
                        trailGradient.addColorStop(0.6, `rgba(255, 0, 0, ${opacity * 0.7})`);
                        trailGradient.addColorStop(1, `rgba(255, 0, 0, 0)`);
                        
                        ctx.fillStyle = trailGradient;
                        ctx.fill();
                        
                        // Add outline to trail segments
                        if (j < 3) { // Only for the first few segments
                            ctx.strokeStyle = `rgba(255, 0, 0, ${opacity * 0.8})`;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                    }
                    
                    // Add some particle effects in the trail
                    for (let j = 0; j < 3; j++) {
                        const particleY = ship.y - ((1 + j) * 20 + Math.random() * 10);
                        const particleX = ship.x + (Math.random() - 0.5) * 10;
                        const particleSize = 2 + Math.random() * 3;
                        const particleOpacity = 0.7 - (j * 0.2);
                        
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 100, 50, ${particleOpacity})`;
                        ctx.fill();
                    }
                }
                
                // Determine asteroid color based on word difficulty or error state
                // Use a base gray color for all asteroids, or red if in error state
                let baseColor, outlineColor;
                
                if (isError) {
                    // Error state - red asteroid
                    baseColor = '#FF3333';
                    outlineColor = '#FF0000';
                } else if (ship.word.length <= 3) {
                    // Small asteroids - lighter gray with reddish outline
                    baseColor = '#777777';
                    outlineColor = '#B71C1C';
                } else if (ship.word.length <= 5) {
                    // Medium asteroids - medium gray with orange outline
                    baseColor = '#666666';
                    outlineColor = '#F57F17';
                } else {
                    // Large asteroids - darker gray with purple outline
                    baseColor = '#555555';
                    outlineColor = '#311B92';
                }
                
                // Calculate asteroid radius based on word length
                const radius = ship.width / 2;
                
                // Save context for rotation
                ctx.save();
                ctx.translate(ship.x, ship.y);
                
                // Apply rotation if defined
                if (ship.rotation !== undefined) {
                    ctx.rotate(ship.rotation);
                }
                
                // Highlight targeted asteroid
                if (ship === currentTargetShip) {
                    // Use red highlight for error state, green otherwise
                    ctx.strokeStyle = isError ? '#FF0000' : '#4CAF50';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Add pulsing glow effect for error state
                    if (isError) {
                        // Stronger pulsing effect
                        const pulseSize = 1 + Math.sin(Date.now() / 100) * 0.3;
                        
                        // Outer glow
                        ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, (radius + 10) * pulseSize, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Inner glow
                        ctx.strokeStyle = 'rgba(255, 50, 50, 0.9)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, (radius + 5) * pulseSize, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
                
                // Create irregular asteroid shape
                ctx.beginPath();
                
                // Use the ship's word as a seed for the asteroid shape
                // This ensures each asteroid has a consistent but unique shape
                const seed = ship.word.charCodeAt(0) + ship.word.length;
                const points = 7 + (ship.word.length % 4); // 7-10 points based on word length
                
                // Create irregular polygon
                for (let i = 0; i < points; i++) {
                    const angle = (i / points) * Math.PI * 2;
                    // Vary the radius to create jagged edges
                    const jitter = 0.8 + (Math.sin(seed + i * 7) * 0.2);
                    const pointRadius = radius * jitter;
                    
                    const x = Math.cos(angle) * pointRadius;
                    const y = Math.sin(angle) * pointRadius;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.closePath();
                
                // Create asteroid texture with gradient and noise
                const gradient = ctx.createRadialGradient(
                    -radius/3, -radius/3, radius/10,
                    0, 0, radius * 1.2
                );
                
                gradient.addColorStop(0, baseColor);
                gradient.addColorStop(0.5, baseColor);
                gradient.addColorStop(1, isError ? '#AA0000' : '#444444');
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Add asteroid outline
                ctx.strokeStyle = outlineColor;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Add crater details to larger asteroids
                if (ship.word.length > 3) {
                    const craters = Math.min(5, Math.floor(ship.word.length / 2));
                    
                    for (let i = 0; i < craters; i++) {
                        // Position craters based on word characters
                        const craterAngle = ((ship.word.charCodeAt(i % ship.word.length) % 10) / 10) * Math.PI * 2;
                        const craterDist = (radius * 0.6) * ((i + 1) / craters);
                        const craterX = Math.cos(craterAngle) * craterDist;
                        const craterY = Math.sin(craterAngle) * craterDist;
                        const craterSize = radius * (0.15 + (i % 3) * 0.05);
                        
                        // Draw crater
                        ctx.beginPath();
                        ctx.arc(craterX, craterY, craterSize, 0, Math.PI * 2);
                        ctx.fillStyle = isError ? 'rgba(100, 0, 0, 0.6)' : 'rgba(40, 40, 40, 0.6)';
                        ctx.fill();
                    }
                }
                
                // Add glowing particles for error state
                if (isError) {
                    const particleCount = 8;
                    for (let i = 0; i < particleCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = radius * (0.7 + Math.random() * 0.3);
                        const particleX = Math.cos(angle) * distance;
                        const particleY = Math.sin(angle) * distance;
                        const particleSize = 1 + Math.random() * 2;
                        
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
                        ctx.fill();
                    }
                }
                
                // Restore context before drawing text
                ctx.restore();
                
                // Draw word with adaptive font sizing based on asteroid size and word length
                // Calculate appropriate font size based on asteroid width and word length
                const maxFontSize = 24;
                const minFontSize = 16;
                
                // Calculate font size based on asteroid size and word length
                // Longer words need smaller fonts to fit inside the asteroid
                const fontSizeByWidth = Math.max(minFontSize, Math.min(maxFontSize, ship.width / (ship.word.length * 0.7)));
                
                // Set font with calculated size
                ctx.font = `bold ${Math.floor(fontSizeByWidth)}px Courier New`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Add stronger text shadow for better readability against the asteroid texture
                ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
                ctx.shadowBlur = 6;
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                
                // Highlight typed portion
                if (ship === currentTargetShip && currentTypingWord.length > 0) {
                    const typedPart = ship.word.substring(0, currentTypingWord.length);
                    const remainingPart = ship.word.substring(currentTypingWord.length);
                    
                    // Measure width of typed part and full word
                    const typedWidth = ctx.measureText(typedPart).width;
                    const fullWidth = ctx.measureText(ship.word).width;
                    
                    // Calculate positions to ensure perfect centering
                    const textStartX = ship.x - fullWidth / 2;
                    
                    // Draw the text in two parts
                    // First, draw the typed part in green
                    ctx.fillStyle = '#4CAF50';
                    
                    // Save the current context to restore after drawing the first part
                    ctx.save();
                    
                    // Set a clip region for the first part of the text
                    ctx.beginPath();
                    ctx.rect(ship.x - fullWidth/2, ship.y - fontSizeByWidth, 
                             typedWidth, fontSizeByWidth * 2);
                    ctx.clip();
                    
                    // Draw the full word - the clipping will only show the first part
                    ctx.fillText(ship.word, ship.x, ship.y);
                    
                    // Restore context for the second part
                    ctx.restore();
                    
                    // Now draw the remaining part in white
                    ctx.fillStyle = 'white';
                    
                    // Save context again
                    ctx.save();
                    
                    // Set a clip region for the second part of the text
                    ctx.beginPath();
                    ctx.rect(ship.x - fullWidth/2 + typedWidth, ship.y - fontSizeByWidth,
                             fullWidth - typedWidth, fontSizeByWidth * 2);
                    ctx.clip();
                    
                    // Draw the full word again - the clipping will only show the second part
                    ctx.fillText(ship.word, ship.x, ship.y);
                    
                    // Restore context
                    ctx.restore();
                } else {
                    // Draw full word in white
                    ctx.fillStyle = 'white';
                    ctx.fillText(ship.word, ship.x, ship.y);
                    
                    // Add subtle glow effect for better visibility
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
                    ctx.shadowBlur = 8;
                    ctx.fillText(ship.word, ship.x, ship.y);
                }
                
                // Reset shadow effects
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }
        }
        
        function drawLasers() {
            for (const laser of lasers) {
                const startX = laser.startX;
                const startY = laser.startY;
                
                const currentX = startX + (laser.targetX - startX) * laser.progress;
                const currentY = startY + (laser.targetY - startY) * laser.progress;
                
                // Draw laser particles first (behind the beam)
                for (const particle of laser.particles) {
                    const alpha = particle.life * 0.7;
                    ctx.fillStyle = `rgba(100, 255, 150, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Create a pulsing effect for the laser
                const pulseTime = (Date.now() - laser.creationTime) / 50;
                const pulseWidth = laser.width * (0.8 + 0.2 * Math.sin(pulseTime));
                
                // Draw laser beam with glow effect
                ctx.save();
                
                // Outer glow
                ctx.shadowColor = '#4CAF50';
                ctx.shadowBlur = 10;
                ctx.lineWidth = pulseWidth;
                ctx.strokeStyle = laser.color;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                
                // Inner core (brighter)
                ctx.lineWidth = pulseWidth * 0.5;
                ctx.strokeStyle = '#AAFFAA';
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                
                ctx.restore();
                
                // Draw laser head with glow
                ctx.save();
                ctx.shadowColor = '#4CAF50';
                ctx.shadowBlur = 15;
                
                // Outer glow
                const headGradient = ctx.createRadialGradient(
                    currentX, currentY, 0,
                    currentX, currentY, 6
                );
                headGradient.addColorStop(0, '#FFFFFF');
                headGradient.addColorStop(0.3, '#AAFFAA');
                headGradient.addColorStop(1, 'rgba(76, 175, 80, 0)');
                
                ctx.fillStyle = headGradient;
                ctx.beginPath();
                ctx.arc(currentX, currentY, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner core
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(currentX, currentY, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        function drawExplosions() {
            for (const explosion of explosions) {
                const progress = explosion.time / explosion.duration;
                
                if (explosion.type === 'fragment') {
                    // Draw asteroid fragment
                    const fadeStart = 0.7; // When to start fading out
                    const opacity = progress > fadeStart ? 
                        1 - ((progress - fadeStart) / (1 - fadeStart)) : 1;
                    
                    ctx.save();
                    ctx.translate(explosion.x, explosion.y);
                    
                    if (explosion.rotation !== undefined) {
                        ctx.rotate(explosion.rotation);
                    }
                    
                    // Draw irregular fragment shape
                    ctx.beginPath();
                    const points = 5; // Simpler shape for fragments
                    const radius = explosion.radius;
                    
                    for (let i = 0; i < points; i++) {
                        const angle = (i / points) * Math.PI * 2;
                        // Vary the radius to create jagged edges
                        const jitter = 0.7 + (Math.sin(i * 7) * 0.3);
                        const pointRadius = radius * jitter;
                        
                        const x = Math.cos(angle) * pointRadius;
                        const y = Math.sin(angle) * pointRadius;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    ctx.closePath();
                    
                    // Create fragment texture with gradient
                    const gradient = ctx.createRadialGradient(
                        0, 0, 0,
                        0, 0, radius
                    );
                    
                    // Fixed color handling
                    if (explosion.color && typeof explosion.color === 'string' && explosion.color.startsWith('#')) {
                        // Convert hex to RGB
                        const hex = explosion.color.substring(1);
                        const r = parseInt(hex.substring(0, 2), 16);
                        const g = parseInt(hex.substring(2, 4), 16);
                        const b = parseInt(hex.substring(4, 6), 16);
                        
                        gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${opacity})`);
                        gradient.addColorStop(1, `rgba(${Math.floor(r*0.7)}, ${Math.floor(g*0.7)}, ${Math.floor(b*0.7)}, ${opacity})`);
                    } else {
                        // Default colors
                        gradient.addColorStop(0, `rgba(120, 120, 120, ${opacity})`);
                        gradient.addColorStop(1, `rgba(80, 80, 80, ${opacity})`);
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    ctx.strokeStyle = `rgba(60, 60, 60, ${opacity})`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    ctx.restore();
                } 
                else if (explosion.type === 'particle') {
                    // Draw small debris particles
                    const fadeStart = 0.6;
                    const opacity = progress > fadeStart ? 
                        1 - ((progress - fadeStart) / (1 - fadeStart)) : 1;
                    
                    ctx.fillStyle = explosion.color || `rgba(255, 200, 100, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add glow for some particles
                    if (explosion.radius > 1.5) {
                        ctx.save();
                        ctx.globalAlpha = opacity * 0.6;
                        ctx.shadowColor = explosion.color || 'rgba(255, 200, 100, 1)';
                        ctx.shadowBlur = 5;
                        ctx.fill();
                        ctx.restore();
                    }
                }
                else if (explosion.type === 'shockwave') {
                    // Draw expanding shockwave ring
                    const ringProgress = Math.pow(progress, 0.7); // Accelerate expansion
                    const ringRadius = explosion.radius * ringProgress;
                    const ringWidth = 3 * (1 - progress); // Gets thinner as it expands
                    
                    ctx.save();
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.7 * (1 - progress)})`; // Fade out
                    ctx.lineWidth = ringWidth;
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                else if (explosion.type === 'score') {
                    // Draw score popup text
                    const fadeStart = 0.7;
                    const opacity = progress > fadeStart ? 
                        1 - ((progress - fadeStart) / (1 - fadeStart)) : 1;
                    
                    ctx.save();
                    ctx.font = 'bold 24px Arial';
                    ctx.fillStyle = `rgba(255, 255, 100, ${opacity})`;
                    ctx.strokeStyle = `rgba(0, 0, 0, ${opacity * 0.5})`;
                    ctx.lineWidth = 3;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Add glow effect
                    ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
                    ctx.shadowBlur = 10;
                    
                    // Draw text with upward movement
                    ctx.strokeText(explosion.text, explosion.x, explosion.y - 20 * progress);
                    ctx.fillText(explosion.text, explosion.x, explosion.y - 20 * progress);
                    ctx.restore();
                }
                else if (explosion.type === 'targeting') {
                    // Draw targeting circle effect
                    const radius = explosion.radius * (1 - progress);
                    const opacity = 0.8 * (1 - progress);
                    
                    ctx.save();
                    ctx.strokeStyle = `rgba(76, 175, 80, ${opacity})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Add targeting lines
                    const lineLength = 10;
                    const positions = [
                        { x: explosion.x, y: explosion.y - radius },  // Top
                        { x: explosion.x + radius, y: explosion.y },  // Right
                        { x: explosion.x, y: explosion.y + radius },  // Bottom
                        { x: explosion.x - radius, y: explosion.y }   // Left
                    ];
                    
                    for (const pos of positions) {
                        const angle = Math.atan2(pos.y - explosion.y, pos.x - explosion.x);
                        const innerX = pos.x - Math.cos(angle) * lineLength;
                        const innerY = pos.y - Math.sin(angle) * lineLength;
                        
                        ctx.beginPath();
                        ctx.moveTo(pos.x, pos.y);
                        ctx.lineTo(innerX, innerY);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                }
                else {
                    // Draw main explosion
                    const radius = explosion.radius * Math.sin(progress * Math.PI);
                    
                    // Create gradient with custom color
                    const baseColor = explosion.color || 'orange';
                    const gradient = ctx.createRadialGradient(
                        explosion.x, explosion.y, 0,
                        explosion.x, explosion.y, radius
                    );
                    
                    if (baseColor === 'red') {
                        // Red explosion for error state
                        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                        gradient.addColorStop(0.2, 'rgba(255, 200, 200, 0.8)');
                        gradient.addColorStop(0.4, 'rgba(255, 100, 100, 0.8)');
                        gradient.addColorStop(0.7, 'rgba(255, 50, 50, 0.8)');
                        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    } else {
                        // Orange/yellow explosion for normal state
                        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                        gradient.addColorStop(0.2, 'rgba(255, 255, 200, 0.8)');
                        gradient.addColorStop(0.4, 'rgba(255, 200, 0, 0.8)');
                        gradient.addColorStop(0.7, 'rgba(255, 100, 0, 0.8)');
                        gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Add glow effect
                    ctx.save();
                    ctx.globalAlpha = 0.5 * (1 - progress);
                    ctx.shadowColor = baseColor === 'red' ? 'rgba(255, 0, 0, 0.8)' : 'rgba(255, 200, 0, 0.8)';
                    ctx.shadowBlur = 30;
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, radius * 0.7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        }
        
        function spawnEnemyShip() {
            // Don't spawn during round transition or if round is complete
            if (isRoundTransition || wordsRemainingInRound <= 0) {
                return;
            }

            // Check if maximum number of ships reached
            if (enemyShips.length >= getMaxShips()) {
                return;
            }

            // Only spawn if we have words remaining in the round
            if (wordsRemainingInRound > 0) {
                let word;
                let attempts = 0;
                const maxAttempts = 20;
                
                do {
                    word = selectWord();
                    attempts++;
                    
                    if (attempts >= maxAttempts) {
                        return;
                    }
                } while (usedFirstLetters.has(word[0].toLowerCase()));
                
                usedFirstLetters.add(word[0].toLowerCase());
                
                // Create asteroid size based on word length
                // Larger minimum size to ensure text fits comfortably
                const minSize = 40;  // Increased from 25
                const maxSize = 90;  // Increased from 60
                
                // Calculate size based on word length with a steeper scaling factor
                // Short words (2-3 chars): medium-small asteroids
                // Medium words (4-6 chars): medium-large asteroids
                // Long words (7+ chars): large asteroids
                const sizeBase = minSize + (word.length * 7);  // Increased multiplier from 5 to 7
                const size = Math.min(maxSize, sizeBase);
                
                // Add some randomness to make asteroids more varied, but less than before
                // to ensure consistent text fitting
                const randomFactor = 0.95 + (Math.random() * 0.1); // 0.95 to 1.05 (narrower range)
                const finalSize = size * randomFactor;
                
                // Make width and height slightly different for more natural look
                const width = finalSize;
                const height = finalSize * (0.9 + (Math.random() * 0.2));
                
                // Add rotation for asteroids
                const rotation = Math.random() * Math.PI * 2;
                const rotationSpeed = (Math.random() - 0.5) * 0.02; // Random rotation direction and speed
                
                // Adjust spawn position to account for padding
                const ship = {
                    word: word,
                    x: Math.random() * (canvas.width - width - EDGE_PADDING * 2) + width / 2 + EDGE_PADDING,
                    y: -height / 2,
                    width: width,
                    height: height,
                    rotation: rotation,
                    rotationSpeed: rotationSpeed
                };
                
                enemyShips.push(ship);
                wordsRemainingInRound--;
            }
        }
        
        function selectWord() {
            // Early rounds (1-2): mostly short words with some medium words
            if (round <= 2) {
                // 70% short words, 30% medium words
                if (Math.random() < 0.7) {
                    return SHORT_WORDS[Math.floor(Math.random() * SHORT_WORDS.length)];
                } else {
                    return MEDIUM_WORDS[Math.floor(Math.random() * MEDIUM_WORDS.length)];
                }
            } 
            // Rounds 3-4: balanced mix of short and medium words
            else if (round <= 4) {
                // 40% short words, 60% medium words
                if (Math.random() < 0.4) {
                    return SHORT_WORDS[Math.floor(Math.random() * SHORT_WORDS.length)];
                } else {
                    return MEDIUM_WORDS[Math.floor(Math.random() * MEDIUM_WORDS.length)];
                }
            }
            // Rounds 5-7: medium words with gradual introduction of long words
            else if (round <= 7) {
                // Calculate long word chance: 5% at round 5, increasing by 5% each round (max 15%)
                const longWordChance = 0.05 * (round - 4);
                // Calculate short word chance: starts at 25% and decreases
                const shortWordChance = Math.max(0.1, 0.25 - 0.05 * (round - 5));
                
                if (Math.random() < longWordChance) {
                    // For long words, start with shorter ones from the long word pool
                    const easierLongWords = LONG_WORDS.filter(word => word.length <= 7);
                    return easierLongWords[Math.floor(Math.random() * easierLongWords.length)];
                } else if (Math.random() < shortWordChance) {
                    return SHORT_WORDS[Math.floor(Math.random() * SHORT_WORDS.length)];
                } else {
                    return MEDIUM_WORDS[Math.floor(Math.random() * MEDIUM_WORDS.length)];
                }
            }
            // Rounds 8-10: still mostly medium words with some long words
            else if (round <= 10) {
                // 15% short, 65% medium, 20% long words
                const rand = Math.random();
                if (rand < 0.15) {
                    return SHORT_WORDS[Math.floor(Math.random() * SHORT_WORDS.length)];
                } else if (rand < 0.8) {
                    return MEDIUM_WORDS[Math.floor(Math.random() * MEDIUM_WORDS.length)];
                } else {
                    // Keep words at a reasonable length
                    const maxLength = Math.min(8, 6 + Math.floor((round - 8) / 2));
                    const filteredLongWords = LONG_WORDS.filter(word => word.length <= maxLength);
                    return filteredLongWords[Math.floor(Math.random() * filteredLongWords.length)];
                }
            }
            // Rounds 11+: challenging mix but still mostly medium words
            else {
                const rand = Math.random();
                // 10% short, 60% medium, 30% long words
                if (rand < 0.1) {
                    return SHORT_WORDS[Math.floor(Math.random() * SHORT_WORDS.length)];
                } else if (rand < 0.7) {
                    return MEDIUM_WORDS[Math.floor(Math.random() * MEDIUM_WORDS.length)];
                } else {
                    // Only 5% chance for extra-long word (10+ characters) after round 12
                    if (round >= 12 && Math.random() < 0.05) {
                        const extraLongWords = LONG_WORDS.filter(word => word.length >= 10);
                        return extraLongWords[Math.floor(Math.random() * extraLongWords.length)];
                    } else {
                        // Regular long words (less than 10 characters)
                        const regularLongWords = LONG_WORDS.filter(word => word.length < 9);
                        return regularLongWords[Math.floor(Math.random() * regularLongWords.length)];
                    }
                }
            }
        }
        
        function handleKeyDown(event) {
            if (!gameActive) return;
            
            // Get the key pressed
            const key = event.key.toLowerCase();
            
            // Ignore non-letter keys
            if (!/^[a-z]$/.test(key)) {
                return;
            }
            
            processKey(key);
        }
        
        function processKey(key) {
            // If no current target, find a ship that starts with the pressed key
            if (!currentTargetShip) {
                for (const ship of enemyShips) {
                    if (ship.word[0].toLowerCase() === key) {
                        currentTargetShip = ship;
                        currentTypingWord = key;
                        
                        // Initialize error state if not present
                        if (currentTargetShip.errorState === undefined) {
                            currentTargetShip.errorState = {
                                isError: false,
                                speedMultiplier: 1.0
                            };
                        }
                        
                        // Add visual feedback for successful targeting
                        createTargetingEffect(ship);
                        
                        // Fire laser
                        fireLaser(ship);
                        break;
                    }
                }
            } 
            // If we have a target, check if the key matches the next letter
            else {
                const nextCharIndex = currentTypingWord.length;
                const nextChar = currentTargetShip.word[nextCharIndex].toLowerCase();
                
                if (key === nextChar) {
                    // Correct key
                    currentTypingWord += key;
                    
                    // Add visual feedback for successful typing
                    createSuccessTypingEffect();
                    
                    // Fire laser
                    fireLaser(currentTargetShip);
                    
                    // Check if word is complete
                    if (currentTypingWord.length === currentTargetShip.word.length) {
                        destroyShip(currentTargetShip);
                    }
                } else {
                    // Incorrect key - activate error state
                    if (!currentTargetShip.errorState) {
                        currentTargetShip.errorState = {
                            isError: false,
                            speedMultiplier: 1.0
                        };
                    }
                    
                    // Set error state - permanently
                    currentTargetShip.errorState.isError = true;
                    
                    // Increase speed by 20%
                    currentTargetShip.errorState.speedMultiplier = 1.2;
                    
                    // Play error sound
                    playErrorSound();
                    
                    // Add visual feedback for the error
                    const flashOverlay = document.createElement('div');
                    flashOverlay.style.position = 'absolute';
                    flashOverlay.style.top = '0';
                    flashOverlay.style.left = '0';
                    flashOverlay.style.width = '100%';
                    flashOverlay.style.height = '100%';
                    flashOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.2)';
                    flashOverlay.style.pointerEvents = 'none';
                    flashOverlay.style.zIndex = '4';
                    flashOverlay.style.opacity = '0.5';
                    document.getElementById('game-container').appendChild(flashOverlay);
                    
                    // Fade out and remove the flash
                    setTimeout(() => {
                        flashOverlay.style.transition = 'opacity 0.3s ease-out';
                        flashOverlay.style.opacity = '0';
                        setTimeout(() => {
                            document.getElementById('game-container').removeChild(flashOverlay);
                        }, 300);
                    }, 100);
                }
            }
        }
        
        function fireLaser(targetShip) {
            const startX = canvas.width / 2;
            const startY = canvas.height - PLAYER_SHIP_HEIGHT / 2;
            
            // Create a more interesting laser color based on progress
            const baseColor = '#4CAF50';
            
            lasers.push({
                startX: startX,
                startY: startY,
                targetX: targetShip.x,
                targetY: targetShip.y,
                progress: 0,
                color: baseColor,
                width: 3,
                particles: [],
                creationTime: Date.now()
            });

            // Play laser sound
            playLaserSound();
        }
        
        function playLaserSound() {
            // Create oscillator for laser sound
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Set up laser sound parameters
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(880, audioContext.currentTime); // Start at A5
            oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.1); // Sweep down to A2
            
            // Set up volume envelope
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            // Connect nodes
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Play sound
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.1);
        }
        
        function destroyShip(ship) {
            // Remove ship from array
            const index = enemyShips.indexOf(ship);
            if (index !== -1) {
                enemyShips.splice(index, 1);
            }
            
            // Remove first letter from used set
            usedFirstLetters.delete(ship.word[0].toLowerCase());
            
            // Create main explosion
            const explosionSize = 20 + ship.word.length * 5;
            explosions.push({
                x: ship.x,
                y: ship.y,
                radius: explosionSize,
                duration: 40, // Longer duration
                time: 0,
                type: 'main',
                color: ship.errorState && ship.errorState.isError ? 'red' : 'orange' // Different color for error state
            });
            
            // Create shockwave effect
            explosions.push({
                x: ship.x,
                y: ship.y,
                radius: explosionSize * 1.5,
                duration: 30,
                time: 0,
                type: 'shockwave'
            });
            
            // Create asteroid fragments
            const fragmentCount = Math.min(12, 4 + Math.floor(ship.word.length / 2));
            
            // Define fragment colors properly
            const errorColors = ['#FF5555', '#FF3333', '#FF0000'];
            const normalColors = ['#777777', '#666666', '#555555'];
            
            for (let i = 0; i < fragmentCount; i++) {
                const angle = (i / fragmentCount) * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                const distance = ship.width / 2;
                
                // Select color based on error state
                const colorArray = ship.errorState && ship.errorState.isError ? errorColors : normalColors;
                const fragmentColor = colorArray[Math.floor(Math.random() * colorArray.length)];
                
                // Create fragment with velocity
                explosions.push({
                    x: ship.x + Math.cos(angle) * distance * 0.5,
                    y: ship.y + Math.sin(angle) * distance * 0.5,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: ship.width / 4 * (0.5 + Math.random() * 0.5),
                    duration: 60, // Longer duration
                    time: 0,
                    type: 'fragment',
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                    color: fragmentColor
                });
            }
            
            // Add small particle debris
            const particleCount = 20 + Math.floor(ship.word.length * 3);
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 0.5 + Math.random() * 4;
                
                // Create proper RGBA colors for particles
                let particleColor;
                if (ship.errorState && ship.errorState.isError) {
                    // Red particles for error state
                    const r = 255;
                    const g = Math.floor(Math.random() * 100);
                    const b = Math.floor(Math.random() * 50);
                    particleColor = `rgba(${r}, ${g}, ${b}, 1)`;
                } else {
                    // Orange/yellow particles for normal state
                    const r = 255;
                    const g = 150 + Math.floor(Math.random() * 100);
                    const b = Math.floor(Math.random() * 100);
                    particleColor = `rgba(${r}, ${g}, ${b}, 1)`;
                }
                
                explosions.push({
                    x: ship.x,
                    y: ship.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 0.5 + Math.random() * 2,
                    duration: 30 + Math.random() * 30,
                    time: 0,
                    type: 'particle',
                    color: particleColor
                });
            }
            
            // Play explosion sound
            playExplosionSound();
            
            // Award points based on word length
            const points = ship.word.length * 10;
            score += points;
            
            // Create score popup
            createScorePopup(ship.x, ship.y, points);
            
            // Reset current typing
            currentTypingWord = '';
            currentTargetShip = null;
            
            // Update HUD
            updateHUD();
            
            // Check for round advancement
            checkRoundAdvancement();
        }
        
        function playExplosionSound() {
            // Create noise for explosion
            const bufferSize = audioContext.sampleRate * 0.5;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            // Generate noise
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            
            // Create noise source
            const noise = audioContext.createBufferSource();
            noise.buffer = buffer;
            
            // Create filters for explosion effect
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1000, audioContext.currentTime);
            filter.frequency.exponentialRampToValueAtTime(20, audioContext.currentTime + 0.3);
            
            // Create volume envelope
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            // Connect nodes
            noise.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Play sound
            noise.start();
            noise.stop(audioContext.currentTime + 0.3);
        }
        
        function checkRoundAdvancement() {
            // Start next round when all words are destroyed and no ships remain
            if (wordsRemainingInRound <= 0 && enemyShips.length === 0 && !isRoundTransition) {
                startNextRound();
            }
        }
        
        function getEnemySpeed() {
            // More aggressive speed increase across all rounds
            if (round <= 3) {
                // Gentle increase for first few rounds
                return ENEMY_SPEED_BASE * (1 + (round - 1) * 0.07);
            } else if (round <= 7) {
                // Moderate increase for middle rounds
                return ENEMY_SPEED_BASE * (1.14 + (round - 3) * 0.1);
            } else {
                // More challenging increase for later rounds to compensate for easier words
                return ENEMY_SPEED_BASE * (1.54 + Math.pow(round - 7, 0.7) * 0.12);
            }
        }
        
        function getSpawnInterval() {
            // More aggressive spawn rate changes
            if (round <= 3) {
                // Keep spawn rate fairly slow in early rounds
                return ENEMY_SPAWN_INTERVAL_BASE - (round - 1) * 120;
            } else if (round <= 7) {
                // Moderate decrease in spawn interval for middle rounds
                return ENEMY_SPAWN_INTERVAL_BASE - 360 - (round - 3) * 170;
            } else {
                // More challenging but not overwhelming for later rounds
                return Math.max(1000, ENEMY_SPAWN_INTERVAL_BASE - 1040 - (round - 7) * 100);
            }
        }
        
        function getMaxShips() {
            // More gradual increase in maximum ships
            if (round <= 3) {
                // Start with fewer ships
                return 2 + Math.floor((round - 1) / 3);
            } else if (round <= 7) {
                // Moderate increase for middle rounds
                return 3 + Math.floor((round - 3) / 3);
            } else {
                // Cap at a reasonable maximum
                return Math.min(5, 4 + Math.floor((round - 7) / 3));
            }
        }
        
        function updateHUD() {
            // Update text content
            document.getElementById('score').textContent = `SCORE: ${score}`;
            document.getElementById('lives').textContent = `LIVES: ${lives}`;
            document.getElementById('round').textContent = `ROUND: ${round}`;
            
            // Update lives display with visual indicators
            const livesElement = document.getElementById('lives');
            let livesHTML = 'LIVES: ';
            
            for (let i = 0; i < lives; i++) {
                livesHTML += '<span class="life-icon">■</span> ';
            }
            
            livesElement.innerHTML = livesHTML;
        }
        
        function endGame() {
            gameActive = false;
            clearInterval(spawnInterval);
            
            // Stop background music
            stopBackgroundMusic();
            
            // Show game over screen
            document.getElementById('game-over').style.display = 'flex';
            document.getElementById('final-score').textContent = `Final Score: ${score}`;
        }
        
        function startNextRound() {
            round++;
            wordsRemainingInRound = WORDS_PER_ROUND;
            isRoundTransition = true;
            
            // Clear any remaining ships
            enemyShips = [];
            usedFirstLetters.clear();
            
            // Show round transition with enhanced styling
            const roundText = document.createElement('div');
            roundText.className = 'round-transition';
            roundText.textContent = `ROUND ${round}`;
            document.getElementById('game-container').appendChild(roundText);
            
            // Remove round text and start next round after delay
            setTimeout(() => {
                document.getElementById('game-container').removeChild(roundText);
                isRoundTransition = false;
                
                // Update spawn interval for new round
                clearInterval(spawnInterval);
                spawnInterval = setInterval(spawnEnemyShip, getSpawnInterval());
                
                updateHUD();
            }, ROUND_TRANSITION_DURATION + ROUND_START_DELAY);
        }

        function startBackgroundMusic() {
            // Get the music toggle button to check if music is enabled
            const musicToggle = document.getElementById('music-toggle');
            const musicEnabled = musicToggle ? musicToggle.textContent.includes('On') : true;
            
            // Don't play music if it's disabled
            if (!musicEnabled) {
                console.log('Music is disabled by user preference');
                return;
            }
            
            // Create a user interaction promise to handle autoplay restrictions
            const userInteractionPromise = new Promise((resolve) => {
                // This will be resolved when the user interacts with the page
                document.addEventListener('click', function clickHandler() {
                    document.removeEventListener('click', clickHandler);
                    resolve();
                }, { once: true });
            });

            // Try to play the music
            backgroundMusic.play().catch(error => {
                console.log('Audio playback failed, waiting for user interaction:', error);
                
                // Add a visible music indicator to the HUD
                const musicStatus = document.createElement('div');
                musicStatus.id = 'music-status';
                musicStatus.textContent = '🔇 Music: Click to enable';
                musicStatus.style.cursor = 'pointer';
                musicStatus.style.marginTop = '10px';
                document.getElementById('hud').appendChild(musicStatus);
                
                // Add click handler specifically for the music status
                musicStatus.addEventListener('click', function() {
                    backgroundMusic.play().then(() => {
                        musicStatus.textContent = '🔊 Music: Playing';
                        setTimeout(() => {
                            musicStatus.style.opacity = '0.5';
                        }, 2000);
                    }).catch(e => {
                        console.error('Still failed to play audio:', e);
                        musicStatus.textContent = '🔇 Music: Failed to enable';
                    });
                });
            });
        }

        function stopBackgroundMusic() {
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0;
        }

        function setupMobileSupport() {
            // Check if we're on a mobile device or small screen
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                          || window.innerWidth <= 768;
            
            if (isMobile) {
                // Create virtual keyboard
                createVirtualKeyboard();
                
                // Setup mobile input field for triggering the native keyboard
                const mobileInput = document.getElementById('mobile-input');
                
                // Handle mobile input from native keyboard
                mobileInput.addEventListener('input', function(e) {
                    if (e.target.value) {
                        // Process the last character typed
                        const key = e.target.value.slice(-1).toLowerCase();
                        processKey(key);
                        
                        // Clear the input field after a short delay
                        setTimeout(() => {
                            e.target.value = '';
                        }, 10);
                    }
                });
                
                // Show native keyboard when canvas is tapped (optional)
                canvas.addEventListener('touchstart', function(e) {
                    if (gameActive) {
                        // Uncomment the next line if you want the native keyboard to appear on canvas tap
                        // mobileInput.focus();
                    }
                });
                
                // Add a toggle button for the keyboard
                const keyboardToggle = document.createElement('div');
                keyboardToggle.id = 'keyboard-toggle';
                keyboardToggle.textContent = '⌨️';
                keyboardToggle.style.position = 'absolute';
                keyboardToggle.style.bottom = '10px';
                keyboardToggle.style.right = '10px';
                keyboardToggle.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                keyboardToggle.style.color = '#4CAF50';
                keyboardToggle.style.padding = '10px';
                keyboardToggle.style.borderRadius = '5px';
                keyboardToggle.style.fontSize = '24px';
                keyboardToggle.style.cursor = 'pointer';
                keyboardToggle.style.zIndex = '10';
                keyboardToggle.style.border = '1px solid rgba(76, 175, 80, 0.5)';
                keyboardToggle.style.boxShadow = '0 0 5px rgba(76, 175, 80, 0.5)';
                
                document.getElementById('game-container').appendChild(keyboardToggle);
                
                // Toggle keyboard visibility
                let keyboardVisible = true;
                const virtualKeyboard = document.getElementById('virtual-keyboard');
                
                keyboardToggle.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    keyboardVisible = !keyboardVisible;
                    virtualKeyboard.style.display = keyboardVisible ? 'block' : 'none';
                    keyboardToggle.textContent = keyboardVisible ? '⌨️' : '🔼';
                    
                    // Adjust canvas height
                    if (keyboardVisible) {
                        canvas.style.height = '75vh';
                    } else {
                        canvas.style.height = '90vh';
                    }
                });
            }
        }

        function createVirtualKeyboard() {
            const keyboard = document.getElementById('virtual-keyboard');
            // Clear any existing content
            keyboard.innerHTML = '';
            
            // Define keyboard rows in QWERTY layout
            const keyboardRows = [
                'qwertyuiop',
                'asdfghjkl',
                'zxcvbnm'
            ];
            
            // Create each row
            keyboardRows.forEach(rowKeys => {
                const rowElement = document.createElement('div');
                rowElement.className = 'key-row';
                
                // Create keys for this row
                for (let i = 0; i < rowKeys.length; i++) {
                    const key = document.createElement('div');
                    key.className = 'key';
                    key.textContent = rowKeys[i];
                    
                    // Add touch event
                    key.addEventListener('touchstart', function(e) {
                        e.preventDefault();
                        processKey(rowKeys[i]);
                        
                        // Visual feedback
                        this.classList.add('active');
                        setTimeout(() => {
                            this.classList.remove('active');
                        }, 150);
                    });
                    
                    rowElement.appendChild(key);
                }
                
                keyboard.appendChild(rowElement);
            });
            
            // Add a retro keyboard label
            const keyboardLabel = document.createElement('div');
            keyboardLabel.style.color = 'rgba(76, 175, 80, 0.7)';
            keyboardLabel.style.textAlign = 'center';
            keyboardLabel.style.fontSize = '12px';
            keyboardLabel.style.fontFamily = 'Courier New, monospace';
            keyboardLabel.style.marginTop = '5px';
            keyboardLabel.style.textShadow = '0 0 5px rgba(76, 175, 80, 0.5)';
            keyboardLabel.textContent = '[ SPACE COMMAND TERMINAL ]';
            keyboard.appendChild(keyboardLabel);
        }

        function playLifeLostSound() {
            // Create a complex alarm sound for life lost
            
            // Main oscillator for the alarm tone
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Create a second oscillator for a more complex sound
            const oscillator2 = audioContext.createOscillator();
            const gainNode2 = audioContext.createGain();
            
            // Create a distortion effect for a harsh warning sound
            const distortion = audioContext.createWaveShaper();
            function makeDistortionCurve(amount) {
                const k = typeof amount === 'number' ? amount : 50;
                const n_samples = 44100;
                const curve = new Float32Array(n_samples);
                const deg = Math.PI / 180;
                
                for (let i = 0; i < n_samples; ++i) {
                    const x = i * 2 / n_samples - 1;
                    curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
                }
                return curve;
            }
            distortion.curve = makeDistortionCurve(20);
            
            // Set up the main alarm tone
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(220, audioContext.currentTime); // A3
            oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.2); // Down to A2
            oscillator.frequency.exponentialRampToValueAtTime(220, audioContext.currentTime + 0.4); // Back to A3
            
            // Set up the secondary tone
            oscillator2.type = 'square';
            oscillator2.frequency.setValueAtTime(440, audioContext.currentTime); // A4
            oscillator2.frequency.exponentialRampToValueAtTime(220, audioContext.currentTime + 0.3); // Down to A3
            
            // Set up volume envelopes
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.05);
            gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.2);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.3);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5);
            
            gainNode2.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode2.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.1);
            gainNode2.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.4);
            
            // Connect nodes
            oscillator.connect(distortion);
            distortion.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator2.connect(gainNode2);
            gainNode2.connect(audioContext.destination);
            
            // Play sound
            oscillator.start();
            oscillator2.start();
            oscillator.stop(audioContext.currentTime + 0.5);
            oscillator2.stop(audioContext.currentTime + 0.5);
            
            // Add visual feedback - flash the screen red briefly
            const flashOverlay = document.createElement('div');
            flashOverlay.style.position = 'absolute';
            flashOverlay.style.top = '0';
            flashOverlay.style.left = '0';
            flashOverlay.style.width = '100%';
            flashOverlay.style.height = '100%';
            flashOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            flashOverlay.style.pointerEvents = 'none';
            flashOverlay.style.zIndex = '4';
            flashOverlay.style.opacity = '0.7';
            document.getElementById('game-container').appendChild(flashOverlay);
            
            // Fade out and remove the flash
            setTimeout(() => {
                flashOverlay.style.transition = 'opacity 0.3s ease-out';
                flashOverlay.style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('game-container').removeChild(flashOverlay);
                }, 300);
            }, 100);
        }

        function playErrorSound() {
            // Create a harsh error sound
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Set up error sound parameters - dissonant frequency
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(220, audioContext.currentTime); // A3
            oscillator.frequency.exponentialRampToValueAtTime(110, audioContext.currentTime + 0.1); // Down to A2
            
            // Set up volume envelope - short and sharp
            gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
            
            // Connect nodes
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Play sound
            oscillator.start();
            oscillator.stop(audioContext.currentTime + 0.2);
        }

        // Add this function to create score popups if it doesn't exist
        function createScorePopup(x, y, points) {
            explosions.push({
                x: x,
                y: y,
                vy: -1, // Move upward
                text: `+${points}`,
                duration: 60,
                time: 0,
                type: 'score'
            });
        }

        // Add this to the window.onload function after the other style additions
        function setupEnhancedHUD() {
            // Add CSS for enhanced HUD
            const style = document.createElement('style');
            style.textContent = `
                #hud {
                    display: flex;
                    flex-direction: column;
                    background-color: rgba(0, 20, 0, 0.7);
                    border: 1px solid #4CAF50;
                    border-radius: 5px;
                    padding: 10px 15px;
                    box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
                    font-family: 'Courier New', monospace;
                    text-shadow: 0 0 5px rgba(76, 175, 80, 0.7);
                    z-index: 5;
                }
                
                #hud div {
                    margin: 5px 0;
                    position: relative;
                    padding-left: 20px; /* Increased from 10px to create more space */
                    line-height: 1.2; /* Add line height to improve vertical spacing */
                }
                
                #hud div:before {
                    content: '>';
                    position: absolute;
                    left: 0;
                    top: 0; /* Align to top */
                    color: #4CAF50;
                    animation: blink 1.5s infinite;
                    width: 15px; /* Fixed width for the character */
                    text-align: center; /* Center the character in its space */
                }
                
                @keyframes blink {
                    0%, 100% { opacity: 1; }
                    50% { opacity: 0.3; }
                }
                
                #score {
                    color: #FFEB3B;
                }
                
                #lives {
                    color: #FF5252;
                }
                
                #round {
                    color: #2196F3;
                }
                
                .life-icon {
                    color: #FF5252;
                    text-shadow: 0 0 8px #FF0000;
                    font-size: 16px;
                    animation: pulse 2s infinite;
                    margin-left: 3px; /* Add spacing between life icons */
                }
                
                @keyframes pulse {
                    0% { text-shadow: 0 0 8px #FF0000; }
                    50% { text-shadow: 0 0 15px #FF0000; }
                    100% { text-shadow: 0 0 8px #FF0000; }
                }
                
                /* Removed duplicate round transition CSS */
            `;
            document.head.appendChild(style);
            
            // Update HUD initially
            updateHUD();
        }

        // Add new functions for visual feedback effects
        function createTargetingEffect(ship) {
            // All targeting visual effects removed
            // The ship will still be targeted functionally, but without visual effects
        }

        function createSuccessTypingEffect() {
            // Create small particle burst at player ship position
            const x = canvas.width / 2;
            const y = canvas.height - PLAYER_SHIP_HEIGHT / 2;
            
            // Add small particles
            for (let i = 0; i < 5; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                const distance = 10;
                
                explosions.push({
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 1 + Math.random() * 2,
                    duration: 20,
                    time: 0,
                    type: 'particle',
                    color: `rgba(100, 255, 100, ${0.7 + Math.random() * 0.3})`
                });
            }
        }
    </script>
</body>
</html> 
